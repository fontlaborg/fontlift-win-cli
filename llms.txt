Project Structure:
ğŸ“ fontlift-win-cli
â”œâ”€â”€ ğŸ“ .github
â”‚   â”œâ”€â”€ ğŸ“ ISSUE_TEMPLATE
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ bug_report.md
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ config.yml
â”‚   â”‚   â””â”€â”€ ğŸ“„ feature_request.md
â”‚   â”œâ”€â”€ ğŸ“ workflows
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ build.yml
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ README.md
â”‚   â”‚   â””â”€â”€ ğŸ“„ release.yml
â”‚   â””â”€â”€ ğŸ“„ PULL_REQUEST_TEMPLATE.md
â”œâ”€â”€ ğŸ“ docs
â”œâ”€â”€ ğŸ“ issues
â”‚   â”œâ”€â”€ ğŸ“„ 101.md
â”‚   â”œâ”€â”€ ğŸ“„ 103.md
â”‚   â”œâ”€â”€ ğŸ“„ 104.md
â”‚   â”œâ”€â”€ ğŸ“„ 201.md
â”‚   â””â”€â”€ ğŸ“„ 999.md
â”œâ”€â”€ ğŸ“ scripts
â”‚   â”œâ”€â”€ ğŸ“„ generate-version-rc.cmd
â”‚   â”œâ”€â”€ ğŸ“„ generate-version-rc.ps1
â”‚   â”œâ”€â”€ ğŸ“„ get-version.cmd
â”‚   â””â”€â”€ ğŸ“„ get-version.ps1
â”œâ”€â”€ ğŸ“ src
â”‚   â”œâ”€â”€ ğŸ“„ exit_codes.h
â”‚   â”œâ”€â”€ ğŸ“„ font_ops.cpp
â”‚   â”œâ”€â”€ ğŸ“„ font_ops.h
â”‚   â”œâ”€â”€ ğŸ“„ font_parser.cpp
â”‚   â”œâ”€â”€ ğŸ“„ font_parser.h
â”‚   â”œâ”€â”€ ğŸ“„ main.cpp
â”‚   â”œâ”€â”€ ğŸ“„ sys_utils.cpp
â”‚   â””â”€â”€ ğŸ“„ sys_utils.h
â”œâ”€â”€ ğŸ“ templates
â”œâ”€â”€ ğŸ“ tools
â”‚   â”œâ”€â”€ ğŸ“„ chocolateyinstall.ps1
â”‚   â”œâ”€â”€ ğŸ“„ cleanup-harness.ps1
â”‚   â”œâ”€â”€ ğŸ“„ collect-fontlift-transcripts.ps1
â”‚   â””â”€â”€ ğŸ“„ test-binary-name.sh
â”œâ”€â”€ ğŸ“„ .gitignore
â”œâ”€â”€ ğŸ“„ build.cmd
â”œâ”€â”€ ğŸ“„ CLAUDE.md
â”œâ”€â”€ ğŸ“„ CONTRIBUTING.md
â”œâ”€â”€ ğŸ“„ DEPENDENCIES.md
â”œâ”€â”€ ğŸ“„ FINAL_STATUS.txt
â”œâ”€â”€ ğŸ“„ fontlift-win.nuspec
â”œâ”€â”€ ğŸ“„ LICENSE
â”œâ”€â”€ ğŸ“„ PLAN.md
â”œâ”€â”€ ğŸ“„ publish.cmd
â”œâ”€â”€ ğŸ“„ README.md
â””â”€â”€ ğŸ“„ TODO.md


<documents>
<document index="1">
<source>.editorconfig</source>
<document_content>
# EditorConfig for fontlift-win-cli
# https://editorconfig.org

root = true

# All files
[*]
charset = utf-8
end_of_line = lf
insert_final_newline = true
trim_trailing_whitespace = true

# C++ source files
[*.{cpp,h,hpp}]
indent_style = space
indent_size = 4
max_line_length = 100

# Batch scripts
[*.{cmd,bat}]
end_of_line = crlf
indent_style = space
indent_size = 4

# Markdown
[*.md]
indent_style = space
indent_size = 2
trim_trailing_whitespace = false  # Allow trailing spaces for line breaks

# YAML
[*.{yml,yaml}]
indent_style = space
indent_size = 2

# JSON
[*.json]
indent_style = space
indent_size = 2

# Git files
[.gitignore]
indent_style = space
indent_size = 2
</document_content>
</document>

<document index="2">
<source>.github/ISSUE_TEMPLATE/bug_report.md</source>
<document_content>
---
name: Bug Report
about: Report a problem with fontlift
title: '[BUG] '
labels: bug
assignees: ''
---

## Bug Description
A clear and concise description of what the bug is.

## Environment
- **Windows Version:** (e.g., Windows 10 21H2, Windows 11)
- **fontlift Version:** (e.g., v0.1.0)
- **Installation Method:** (binary download / built from source)

## Command Used
```cmd
fontlift [command here]
```

## Expected Behavior
What you expected to happen.

## Actual Behavior
What actually happened.

## Error Messages
```
[Paste any error messages here]
```

## Steps to Reproduce
1. Run command `fontlift install font.ttf`
2. Observe error message
3. ...

## Font File Details (if applicable)
- **Font Format:** (.ttf / .otf / .ttc / .otc)
- **Font Name:** (e.g., Arial, MyCustomFont)
- **File Size:** (approximate)
- **Can share file:** (yes / no)

## Administrator Privileges
- [ ] Running as Administrator
- [ ] Running as regular user

## Additional Context
Add any other context about the problem here. Screenshots, logs, or related issues.

## Checklist
- [ ] I have checked existing issues for duplicates
- [ ] I have tested with the latest version
- [ ] I have included all requested information above
</document_content>
</document>

<document index="3">
<source>.github/ISSUE_TEMPLATE/config.yml</source>
<document_content>
blank_issues_enabled: true
contact_links:
  - name: Documentation
    url: https://github.com/fontlaborg/fontlift-win-cli/blob/main/README.md
    about: Check the README for usage examples and troubleshooting
  - name: Contributing Guidelines
    url: https://github.com/fontlaborg/fontlift-win-cli/blob/main/CONTRIBUTING.md
    about: Learn how to contribute to fontlift-win-cli
</document_content>
</document>

<document index="4">
<source>.github/ISSUE_TEMPLATE/feature_request.md</source>
<document_content>
---
name: Feature Request
about: Suggest an enhancement for fontlift
title: '[FEATURE] '
labels: enhancement
assignees: ''
---

## Feature Summary
A clear and concise description of the feature you'd like.

## Problem Statement
What problem does this feature solve? Why do you need it?

**Example:** "I frequently need to install 50+ fonts at once, but running fontlift install for each one is tedious."

## Proposed Solution
Describe how you envision the feature working.

**Example:** "Add `fontlift install -d DIRECTORY` to install all fonts in a directory."

## Alternative Solutions
Have you considered any alternative approaches? List them here.

## Alignment with Project Scope
fontlift is intentionally minimal and focused on core font management. Consider:
- Does this fit the "simple CLI tool" philosophy?
- Can existing features solve this with scripting?
- Would this add significant complexity?

## Use Cases
Describe specific scenarios where you would use this feature.

1. Use case 1: ...
2. Use case 2: ...

## Additional Context
Add any other context, mockups, or examples about the feature request here.

## Checklist
- [ ] I have checked existing issues and PRs for similar requests
- [ ] I have considered if this fits the project scope
- [ ] I have described specific use cases
- [ ] I am willing to contribute if this is accepted
</document_content>
</document>

<document index="5">
<source>.github/PULL_REQUEST_TEMPLATE.md</source>
<document_content>
---
this_file: .github/PULL_REQUEST_TEMPLATE.md
---

# Pull Request

## Summary
- Purpose:
- User-visible impact:
- Linked issues (`Fixes #123`):

## Changes
- Code paths touched:
- Documentation updates:
- Tests added or adjusted (explain if not applicable):

## Validation
- [ ] `build.cmd` (or equivalent) on Windows succeeds without warnings
- [ ] Manual checks cover affected commands (`list`, `install`, `uninstall`, `remove`)
- [ ] Edge cases considered (missing font, duplicate install, permission error)
- [ ] Release artifacts unaffected or updated intentionally

## Checklist
- [ ] Read CONTRIBUTING.md and principles
- [ ] Added/verified `this_file` markers and headers
- [ ] Functions stay under 20 lines, files under 200 lines
- [ ] Updated TODO/PLAN/WORK where applicable
- [ ] Documented verification steps in commit message or comments

## Notes
- Outstanding risks or follow-up items:
- Screenshots / logs (optional):
</document_content>
</document>

<document index="6">
<source>.github/workflows/README.md</source>
<document_content>
# GitHub Actions Workflows
<!-- this_file: .github/workflows/README.md -->

This directory contains automated CI/CD workflows for fontlift-win-cli.

## Workflows

### build.yml - CI Build

**Trigger:** Push to `main` branch or pull requests

**Purpose:** Validate that the code compiles and runs correctly

**Steps:**
1. Checkout code with full git history
2. Setup MSVC compiler environment
3. Extract version from git tags (or use `v0.0.0-dev` if no tags exist)
4. Build fontlift.exe with embedded version resource
5. Test that executable was created
6. Test that executable runs without errors
7. Upload executable as build artifact (7-day retention)

**Artifacts:** `fontlift-{version}` containing `fontlift.exe`

### release.yml - Release Creation

**Trigger:** Push tag matching `v*.*.*` (e.g., `v0.1.0`, `v1.2.3`)

**Purpose:** Create GitHub releases with distribution packages

**Steps:**
1. Checkout code with full git history
2. Setup MSVC compiler environment
3. Extract version from tag name
4. Build fontlift.exe with version embedded
5. Package distribution zip: `fontlift-v{X.Y.Z}.zip`
6. Generate SHA256 checksums
7. Create GitHub Release with auto-generated release notes
8. Upload zip and checksums as release assets

**Release Assets:**
- `fontlift-v{X.Y.Z}.zip` - Distribution package
- `checksums.txt` - SHA256 checksums for verification

## Version Management

Version is managed through git tags:

- **No tags:** Uses `v0.0.0-dev` as version
- **Tagged release:** Uses tag name (e.g., `v1.2.3` â†’ version `1.2.3`)

Version is embedded in:
1. Windows executable resource (visible in file properties)
2. Distribution zip filename
3. Distribution README.txt
4. GitHub Release metadata

## Creating a Release

To create a new release:

1. Ensure all changes are committed and tests pass
2. Update CHANGELOG.md with release notes
3. Create and push an annotated tag:
   ```bash
   git tag -a v0.1.0 -m "Release v0.1.0"
   git push origin v0.1.0
   ```
4. GitHub Actions will automatically:
   - Build the executable with version v0.1.0
   - Package fontlift-v0.1.0.zip
   - Create GitHub Release
   - Upload release artifacts

## Testing Workflows Locally

Workflows use Windows-specific commands and cannot be tested on macOS/Linux.

To test changes:
1. Push to a feature branch
2. Create a pull request
3. CI build workflow will run automatically
4. Review build logs for any errors

For release workflow testing:
1. Create a test tag: `git tag v0.0.1-test`
2. Push tag: `git push origin v0.0.1-test`
3. Workflow will run and create a release
4. Delete test release and tag if successful

## Troubleshooting

**Build fails with "cl.exe not found":**
- MSVC setup step failed
- Check that `ilammy/msvc-dev-cmd@v1` action is working

**Version shows as "0.0.0-dev":**
- No git tags exist, or fetch-depth: 0 is missing
- Ensure checkout step includes `fetch-depth: 0`

**Release workflow doesn't trigger:**
- Tag doesn't match `v*.*.*` pattern
- Ensure tag has format: `v1.2.3` (semantic versioning)

**Checksum generation fails:**
- Zip file wasn't created
- Check publish.cmd output for errors
</document_content>
</document>

<document index="7">
<source>.github/workflows/build.yml</source>
<document_content>
# this_file: .github/workflows/build.yml
# CI Build Workflow - builds and tests on every push and PR

name: CI Build

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: windows-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch all history for git describe

    - name: Setup MSVC
      uses: ilammy/msvc-dev-cmd@v1

    - name: Resolve version
      id: version
      shell: pwsh
      run: |
        # Call get-version.ps1 to derive version from git tags
        # Returns JSON with: base (X.Y.Z), semver (X.Y.Z-pre+build), tag (vX.Y.Z...)
        # Handles repos without tags by falling back to 0.0.0-dev.{count}+g{sha}
        # FALLBACK: If version resolution fails, use safe defaults
        try {
          $json = & scripts/get-version.ps1 -Format Json -ErrorAction Stop
          $info = $json | ConvertFrom-Json
          $base = $info.base
          $semver = $info.semver
          $tag = $info.tag
        } catch {
          Write-Warning "Version resolution failed: $_"
          Write-Warning "Using fallback version 0.0.0-unknown"
          $base = "0.0.0"
          $semver = "0.0.0-unknown"
          $tag = "v0.0.0-unknown"
        }

        # Export to GITHUB_ENV for use in subsequent steps
        "VERSION_BASE=$base" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
        "VERSION_SEMVER=$semver" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
        "VERSION_TAG=$tag" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
        Write-Host "Resolved version: $semver (tag: $tag)"

    - name: Display version
      shell: cmd
      run: |
        echo Building base version %VERSION_BASE%
        echo Building semantic version %VERSION_SEMVER%

    - name: Build
      shell: cmd
      run: build.cmd %VERSION_SEMVER%

    - name: Test executable exists
      shell: cmd
      run: |
        if not exist build\fontlift.exe exit /b 1
        echo Build successful - fontlift.exe created

    - name: Test executable runs
      shell: cmd
      run: |
        REM Running without args shows usage (exit code 1), which is expected
        build\fontlift.exe
        if %ERRORLEVEL% EQU 1 (
          echo Executable runs correctly - showed usage message
          exit /b 0
        ) else (
          echo ERROR: Unexpected exit code %ERRORLEVEL%
          exit /b 1
        )

    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: fontlift-${{ env.VERSION_TAG }}
        path: build/fontlift.exe
        retention-days: 7
</document_content>
</document>

<document index="8">
<source>.github/workflows/release.yml</source>
<document_content>
# this_file: .github/workflows/release.yml
# Release Workflow - creates GitHub releases when tags are pushed

name: Release

on:
  push:
    tags:
      - 'v*.*.*'

jobs:
  release:
    runs-on: windows-latest
    permissions:
      contents: write

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0

    - name: Setup MSVC
      uses: ilammy/msvc-dev-cmd@v1

    - name: Resolve version from tag
      id: version
      shell: pwsh
      run: |
        $ref = $env:GITHUB_REF
        Write-Host "GITHUB_REF = $ref"

        # Multi-level fallback strategy for version resolution
        $base = $null
        $semver = $null
        $tag = $null

        # Level 1: Try to extract version from tag and validate with get-version.ps1
        try {
          # Extract tag name from refs/tags/vX.Y.Z
          if ($ref -match '^refs/tags/v?(.+)$') {
            $version = $matches[1]
            Write-Host "Extracted version from tag: $version"

            # Validate and format with get-version.ps1
            $json = & scripts/get-version.ps1 -TargetVersion "$version" -Format Json -ErrorAction Stop
            $info = $json | ConvertFrom-Json
            $base = $info.base
            $semver = $info.semver
            $tag = $info.tag
            Write-Host "Validated version: $semver"
          } else {
            throw "Unable to match version pattern in ref: $ref"
          }
        } catch {
          Write-Warning "Level 1 failed: $_"

          # Level 2: Try to use raw tag name directly
          try {
            if ($ref -match '^refs/tags/v?(.+)$') {
              $version = $matches[1]
              # Basic version validation: X.Y.Z format
              if ($version -match '^\d+\.\d+\.\d+') {
                $base = $version -replace '[-+].*$', ''
                $semver = $version
                $tag = "v$version"
                Write-Warning "Level 2: Using raw tag version: $semver"
              } else {
                throw "Invalid version format: $version"
              }
            } else {
              throw "Cannot extract version from ref"
            }
          } catch {
            Write-Warning "Level 2 failed: $_"

            # Level 3: Last resort - use timestamp-based version
            $timestamp = Get-Date -Format "yyyyMMdd.HHmmss"
            $base = "0.0.0"
            $semver = "0.0.0-unknown.$timestamp"
            $tag = "v$semver"
            Write-Warning "Level 3: Using fallback version: $semver"
          }
        }

        # Export to GITHUB_ENV
        "VERSION_BASE=$base" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
        "VERSION_SEMVER=$semver" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
        "VERSION_TAG=$tag" | Out-File -FilePath $env:GITHUB_ENV -Append -Encoding utf8
        Write-Host "Final resolved version: $semver (tag: $tag)"

    - name: Build release
      shell: cmd
      run: build.cmd %VERSION_SEMVER%

    - name: Package release
      shell: cmd
      run: publish.cmd %VERSION_SEMVER%

    - name: Generate checksums
      shell: cmd
      run: |
        cd dist
        certutil -hashfile fontlift-%VERSION_TAG%.zip SHA256 > checksums.txt
        type checksums.txt

    - name: Create GitHub Release
      uses: softprops/action-gh-release@v1
      with:
        files: |
          dist/fontlift-${{ env.VERSION_TAG }}.zip
          dist/checksums.txt
        generate_release_notes: true
        draft: false
        prerelease: false
        body: |
          ## fontlift-win-cli ${{ env.VERSION_TAG }}

          Windows CLI tool for font installation and management.

          ### Installation
          1. Download `fontlift-${{ env.VERSION_TAG }}.zip`
          2. Verify checksum (see `checksums.txt`)
          3. Extract `fontlift.exe` to a directory in your PATH
          4. Run `fontlift.exe` from an elevated command prompt

          ### Usage
          ```
          fontlift list              List installed fonts
          fontlift install font.ttf  Install a font
          fontlift uninstall -n Arial  Uninstall a font
          fontlift remove -p font.ttf  Remove font and delete file
          ```

          See [README.md](https://github.com/fontlaborg/fontlift-win-cli/blob/main/README.md) for full documentation.
</document_content>
</document>

<document index="9">
<source>.gitignore</source>
<document_content>
# Prerequisites
*.d

# Compiled Object files
*.slo
*.lo
*.o
*.obj

# Precompiled Headers
*.gch
*.pch

# Linker files
*.ilk

# Debugger Files
*.pdb

# Compiled Dynamic libraries
*.so
*.dylib
*.dll

# Fortran module files
*.mod
*.smod

# Compiled Static libraries
*.lai
*.la
*.a
*.lib

# Executables
*.exe
*.out
*.app

# debug information files
*.dwo

# Build directories
build/
dist/

# Generated files
src/version.rc

# MSVC files
*.suo
*.user
*.userosscache
*.sln.docstates
*.VC.db
*.VC.VC.opendb
.vs/

# IDE files
.vscode/
.idea/
*.swp
*.swo
*~

# OS files
.DS_Store
Thumbs.db

# Issue tracking logs
issues/logs_*/
</document_content>
</document>

<document index="10">
<source>CLAUDE.md</source>
<document_content>
# Development Guidelines

## Quick-Start Checklist

**For every task, follow this baseline:**

1. [ ] Read `README.md`, `PLAN.md`, `TODO.md`, `WORK.md` to understand context
2. [ ] Apply Chain-of-Thought: "Let me think step by step..."
3. [ ] Search when <90% confident (codebase, references, web)
4. [ ] Check if this problem has been solved before (packages > custom code)
5. [ ] Write the test FIRST, then minimal code to pass
6. [ ] Test edge cases (empty, None, negative, huge inputs)
7. [ ] Run full test suite after changes
8. [ ] Update documentation (`WORK.md`, `CHANGELOG.md`)
9. [ ] Self-correct: "Wait, but..." and critically review
10. [ ] Delete rather than add when possible

## Normative Language Convention

- **MUST** â€“ Hard requirements, no exceptions
- **SHOULD** â€“ Default behavior; deviate only with clear justification  
**MAY** â€“ Optional practices or suggestions

---

## I. OPERATING MODEL

You are a Senior Software Engineer obsessed with ruthless minimalism, absolute accuracy, and rigorous verification. You are skeptical of complexity, assumptions, and especially your own first instincts.

### 1.1 Enhanced Chain-of-Thought Process (MUST)

Before ANY response, apply this three-phase thinking:

1. **Analyze** â€“ "Let me think step by step..."
   - Deconstruct the request completely
   - Identify constraints and edge cases
   - Question implicit assumptions

2. **Abstract (Step-Back)** â€“ Zoom out before diving in
   - What high-level patterns apply?
   - What are 2-3 viable approaches?
   - What are the trade-offs?

3. **Execute** â€“ Select the most minimal, verifiable path
   - Your output MUST be what you'd produce after finding and fixing three critical issues

### 1.2 Communication: Anti-Sycophancy (MUST)

**Accuracy is non-negotiable. Facts over feelings.**

- **NEVER** use validation phrases: "You're right", "Great idea", "Exactly"
- **ALWAYS** challenge incorrect statements immediately with "Actually, that's incorrect because..."
- **MUST** state confidence explicitly:
  - "I'm certain (>95% confidence)"
  - "I believe (70-95% confidence)" 
  - "This is an educated guess (<70% confidence)"
- When <90% confident, **MUST** search before answering
- LLMs can hallucinate â€“ treat all outputs (including your own) with skepticism

### 1.3 Mandatory Self-Correction Phase (MUST)

After drafting any solution:

1. Say "Wait, but..." and critique ruthlessly
2. Check: Did I add unnecessary complexity? Are there untested assumptions? 
3. Revise based on the critique before delivering

### 1.4 Context Awareness (SHOULD)

- **FREQUENTLY** state which project/directory you're working in
- **ALWAYS** explain the WHY behind changes
- No need for manual `this_file` tracking â€“ that's impractical overhead

---

## II. CORE PHILOSOPHY

### 2.1 The Prime Directive: Ruthless Minimalism (MUST)

**Complexity is debt. Every line of code is a liability.**

- **YAGNI**: Build only what's required NOW
- **Delete First**: Can we remove code instead of adding?
- **One-Sentence Scope**: Define project scope in ONE sentence and reject everything else

### 2.2 Build vs Buy (MUST Prefer Buy)

**Package-First Workflow:**

1. **Search** existing solutions (PyPI, npm, crates.io, GitHub)
2. **Evaluate** packages: >1000 stars, recent updates, good docs, minimal deps
3. **Prototype** with a small PoC to verify
4. **Use** the package â€“ only write custom code if no suitable package exists

### 2.3 Test-Driven Development (MUST)

**Untested code is broken code.**

1. **RED** â€“ Write a failing test first
2. **GREEN** â€“ Write minimal code to pass
3. **REFACTOR** â€“ Clean up while keeping tests green
4. **VERIFY** â€“ Test edge cases, error conditions, integration

### 2.4 Complexity Triggers â€“ STOP Immediately If You See:

- "General purpose" utility functions
- Abstractions for "future flexibility"
- Custom parsers, validators, formatters
- Any Manager/Handler/System/Framework class
- Functions >20 lines, Files >200 lines, >3 indentation levels
- Security hardening, performance monitoring, analytics

---

## III. STANDARD OPERATING PROCEDURE

### 3.1 Before Starting (MUST)

1. Read `README.md`, `WORK.md`, `CHANGELOG.md`, `PLAN.md`, `TODO.md`
2. Run existing tests to understand current state
3. Apply Enhanced CoT (Analyze â†’ Abstract â†’ Execute)
4. Search for existing solutions before writing code

### 3.2 During Work â€“ Baseline Mode (MUST)

For **every** change:

1. Write test first
2. Implement minimal code
3. Run tests
4. Document in `WORK.md`

### 3.3 During Work â€“ Enhanced Mode (SHOULD for major changes)

For significant features or risky changes:

1. All baseline steps PLUS:
2. Test all edge cases comprehensively
3. Test error conditions (network, permissions, missing files)
4. Performance profiling if relevant
5. Security review if handling user input
6. Update all related documentation

### 3.4 After Work (MUST)

1. Run full test suite
2. Self-correction phase: "Wait, but..."
3. Update `CHANGELOG.md` with changes
4. Update `TODO.md` status markers
5. Verify nothing broke

---

## IV. LANGUAGE-SPECIFIC GUIDELINES

### 4.1 Python

#### Modern Toolchain (MUST)

- **Package Management**: `uv` exclusively (not pip, not conda)
- **Python Version**: 3.12+ via `uv` (never system Python)
- **Virtual Environments**: Always use `uv venv`
- **Formatting & Linting**: `ruff` (replaces black, flake8, isort, pyupgrade)
- **Type Checking**: `mypy` or `pyright` (mandatory for all code)
- **Testing**: `pytest` with `pytest-cov`, `pytest-randomly`

#### Project Layout (SHOULD)

```
project/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ package_name/
â”œâ”€â”€ tests/
â”œâ”€â”€ pyproject.toml
â””â”€â”€ README.md
```

#### Core Packages to Prefer (SHOULD)

- **CLI**: `typer` or `fire` + `rich` for output
- **HTTP**: `httpx` (not requests)
- **Data Validation**: `pydantic` v2
- **Logging**: `loguru` or `structlog` (structured logs)
- **Async**: `asyncio` with `FastAPI` for web
- **Data Formats**: JSON, SQLite, Parquet (not CSV for production)
- **Config**: Environment variables or TOML (via `tomllib`)

#### Code Standards (MUST)

- Type hints on EVERY function
- Docstrings explaining WHAT and WHY
- Use dataclasses or Pydantic for data structures
- `pathlib` for paths (not os.path)
- f-strings for formatting

#### Testing (MUST)

```bash
# Run with coverage
pytest --cov=src --cov-report=term-missing --cov-fail-under=80

# With ruff cleanup
uvx ruff check --fix . && uvx ruff format . && pytest
```

### 4.2 Rust

#### Toolchain (MUST)

- **Build**: `cargo` for everything
- **Format**: `cargo fmt` (no exceptions)
- **Lint**: `cargo clippy -- -D warnings`
- **Security**: `cargo audit` and `cargo deny`

#### Core Principles (MUST)

- **Ownership First**: Leverage the type system to prevent invalid states
- **Minimize `unsafe`**: Isolate, document, and audit any unsafe code
- **Error Handling**: Use `Result<T, E>` everywhere
  - Libraries: `thiserror` for error types
  - Applications: `anyhow` for error context
- **No `panic!` in libraries**: Only in truly unrecoverable situations

#### Concurrency (SHOULD)

- **Async Runtime**: `tokio` (default choice)
- **HTTP**: `reqwest` or `axum`
- **Serialization**: `serde` with `serde_json`
- **CLI**: `clap` with derive macros
- **Logging**: `tracing` with `tracing-subscriber`

#### Security (MUST)

- Enable integer overflow checks in debug
- Validate ALL external input
- Use `cargo-audit` in CI
- Prefer safe concurrency primitives (`Arc`, `Mutex`) 
- Use vetted crypto crates only (`ring`, `rustls`)

### 4.3 Web Development

#### Frontend (TypeScript/React)

##### Toolchain (MUST)

- **Package Manager**: `pnpm` (not npm, not yarn)
- **Bundler**: `vite` 
- **TypeScript**: `strict: true` in tsconfig.json
- **Framework**: Next.js (React) or SvelteKit (Svelte)
- **Styling**: Tailwind CSS
- **State**: Local state first, then Zustand/Jotai (avoid Redux)

##### Core Requirements (MUST)

- **Mobile-First**: Design for mobile, enhance for desktop
- **Accessibility**: WCAG 2.1 AA compliance minimum
- **Performance**: Optimize Core Web Vitals (LCP < 2.5s, FID < 100ms)
- **Security**: Sanitize inputs, implement CSP headers
- **Type Safety**: Zod for runtime validation at API boundaries

##### Best Practices (SHOULD)

- Server-side rendering for initial page loads
- Lazy loading for images and components
- Progressive enhancement
- Semantic HTML
- Error boundaries for graceful failures

#### Backend (Node.js/API)

##### Standards (MUST)

- **Framework**: Express with TypeScript or Fastify
- **Validation**: Zod or Joi for input validation
- **Auth**: Use established libraries (Passport, Auth0)
- **Database**: Prisma or Drizzle ORM
- **Testing**: Vitest or Jest with Supertest

##### Security (MUST)

- Rate limiting on all endpoints
- HTTPS only
- Helmet.js for security headers
- Input sanitization
- SQL injection prevention via parameterized queries

---

## V. PROJECT DOCUMENTATION

### Required Files (MUST maintain)

- **README.md** â€“ Purpose and quick start (<200 lines)
- **CHANGELOG.md** â€“ Cumulative release notes
- **PLAN.md** â€“ Detailed future goals and architecture
- **TODO.md** â€“ Flat task list from PLAN.md with status:
  - `[ ]` Not started
  - `[x]` Completed  
  - `[~]` In progress
  - `[-]` Blocked
  - `[!]` High priority
- **WORK.md** â€“ Current work log with test results
- **DEPENDENCIES.md** â€“ Package list with justifications

---

## VI. SPECIAL COMMANDS

### `/plan [requirement]` (Enhanced Planning)

When invoked, MUST:

1. **Research** existing solutions extensively
2. **Deconstruct** into core requirements and constraints
3. **Analyze** feasibility and identify packages to use
4. **Structure** into phases with dependencies
5. **Document** in PLAN.md with TODO.md checklist

### `/test` (Comprehensive Testing)

**Python:**
```bash
uvx ruff check --fix . && uvx ruff format . && pytest -xvs
```

**Rust:**
```bash
cargo fmt --check && cargo clippy -- -D warnings && cargo test
```

**Then** perform logic verification on changed files and document in WORK.md

### `/work` (Execution Loop)

1. Read TODO.md and PLAN.md
2. Write iteration goals to WORK.md
3. **Write tests first**
4. Implement incrementally
5. Run /test continuously
6. Update documentation
7. Continue to next item

### `/report` (Progress Update)

1. Analyze recent changes
2. Run full test suite
3. Update CHANGELOG.md
4. Clean up completed items from TODO.md

---

## VII. LLM PROMPTING PATTERNS

### Chain-of-Thought (CoT)

For complex reasoning tasks, ALWAYS use:
```
"Let me think step by step...
1. First, I need to...
2. Then, considering...
3. Therefore..."
```

### ReAct Pattern (for Tool Use)

When using external tools:
```
Thought: What information do I need?
Action: [tool_name] with [parameters]
Observation: [result]
Thought: Based on this, I should...
```

### Self-Consistency

For critical decisions:
1. Generate multiple solutions
2. Evaluate trade-offs
3. Select best approach with justification

### Few-Shot Examples

When generating code/tests, provide a minimal example first:
```python
# Example test pattern:
def test_function_when_valid_input_then_expected_output():
    result = function(valid_input)
    assert result == expected, "Clear failure message"
```

---

## VIII. ANTI-BLOAT ENFORCEMENT

### Scope Discipline (MUST)

Define scope in ONE sentence. Reject EVERYTHING else.

### RED LIST â€“ NEVER Add Unless Explicitly Required:

- Analytics/metrics/telemetry
- Performance monitoring/profiling  
- Production error frameworks
- Advanced security beyond input validation
- Health monitoring/diagnostics
- Circuit breakers/sophisticated retry
- Complex caching systems
- Configuration validation frameworks
- Backup/recovery mechanisms
- Benchmarking suites

### GREEN LIST â€“ Acceptable Additions:

- Basic try/catch error handling
- Simple retry (â‰¤3 attempts)
- Basic logging (print or loguru)
- Input validation for required fields
- Help text and examples
- Simple config files (TOML)
- Core functionality tests

### Complexity Limits (MUST)

- Simple utilities: 1-3 commands
- Standard tools: 4-7 commands  
- Over 8 commands: Probably over-engineered
- Could fit in one file? Keep it in one file
- Weekend rewrite test: If it takes longer, it's too complex

---

## IX. PROSE WRITING

When writing documentation or commentary:

- **First line sells the second line** â€“ No throat-clearing
- **Transformation over features** â€“ Show the change, not the tool
- **One person, one problem** â€“ Specific beats generic
- **Conflict creates interest** â€“ What's at stake?
- **Kill your darlings** â€“ If it doesn't serve the reader, delete it
- **Enter late, leave early** â€“ Start in action, end before over-explaining
- **No corporate jargon** â€“ Clear, concrete language only
- **Light humor allowed** â€“ But clarity comes first
- **Skepticism is healthy** â€“ Question everything, including this guide

---

**Remember: The best code is no code. The second best is someone else's well-tested code. Write as little as possible, test everything, and delete ruthlessly.**

## Gemini Added Memories
- I must always ask for confirmation before running any command that deletes files. The user must explicitly approve the deletion. I should explain what the command does and which files will be deleted.
All files, usage notes, GUIs, CLI helps, documentation etc. should carry a mention `made by FontLab https://www.fontlab.com/` where it makes sense.
</document_content>
</document>

<document index="11">
<source>CONTRIBUTING.md</source>
<document_content>
# Contributing to fontlift-win-cli

Thank you for your interest in contributing to fontlift-win-cli! This document provides guidelines for contributing to the project.

## Code of Conduct

- Be respectful and constructive
- Focus on what is best for the project and community
- Show empathy towards other contributors
- Accept constructive criticism gracefully

## How to Contribute

### Reporting Bugs

Before creating a bug report:
1. Check existing issues to avoid duplicates
2. Test with the latest version
3. Verify the bug on a clean Windows installation if possible

When creating a bug report, include:
- Windows version (e.g., Windows 10, Windows 11)
- fontlift-win version
- Exact command used
- Expected behavior
- Actual behavior
- Error messages (if any)
- Steps to reproduce

### Suggesting Features

Feature requests are welcome, but remember:
- fontlift-win is intentionally minimal and focused
- New features must align with the project's core purpose
- Complex features may be rejected to maintain simplicity

When suggesting a feature:
- Explain the problem it solves
- Describe the proposed solution
- Consider whether it fits the project scope
- Check if existing features can solve the problem

### Pull Requests

#### Before You Start

1. Check open issues and PRs to avoid duplicate work
2. For major changes, open an issue first to discuss
3. Read PLAN.md and TODO.md to understand the roadmap
4. Ensure you have a Windows development environment

#### Development Setup

```cmd
# Clone the repository
git clone https://github.com/fontlaborg/fontlift-win-cli.git
cd fontlift-win-cli

# Build the project
build.cmd
```

**Requirements:**
- Windows 7 or later
- Visual Studio 2017 or later (for MSVC)
- Git

#### Coding Standards

**C++ Code Style:**
- C++17 standard
- Functions: maximum 20 lines
- Files: maximum 200 lines
- Indentation: maximum 3 levels
- Use 4 spaces for indentation (no tabs)
- Maximum line length: 100 characters

**Naming Conventions:**
- Functions: `PascalCase()` (e.g., `ListFonts()`)
- Variables: `camelCase` (e.g., `hasPathFlag`)
- Constants: `UPPER_CASE` (e.g., `EXIT_SUCCESS_CODE`)

**File Headers:**
All source files must include:
```cpp
// this_file: path/to/file.cpp
// fontlift-win-cli - Windows font management CLI tool
// Copyright 2025 by Fontlab Ltd. Licensed under Apache 2.0
```

Use templates in `templates/` directory for new files.

**Code Quality:**
- No dynamic memory allocation (use stack variables)
- Prefer Windows API over third-party libraries
- Add comments for complex logic
- Handle error cases explicitly
- Validate all inputs

**What NOT to Add:**
- External dependencies (keep it dependency-free)
- Configuration files (use command-line arguments only)
- Logging frameworks
- Analytics or telemetry
- Auto-update mechanisms
- GUI components

See PRINCIPLES.md for complete design philosophy.

#### Testing

Before submitting:
1. Build successfully with no warnings
2. Test all commands manually:
   - `fontlift-win list` with various flags
   - `fontlift-win install` with .ttf, .otf, .ttc files
   - `fontlift-win uninstall` by path and name
   - `fontlift-win remove` by path and name
3. Test edge cases:
   - Filenames with spaces
   - Invalid font files
   - Without administrator privileges
   - Fonts in non-standard locations
4. Verify fonts persist after reboot
5. Check code follows style guidelines

#### Commit Messages

Format:
```
Brief summary (50 chars or less)

Detailed explanation if needed:
- What changed and why
- Impact on existing functionality
- Breaking changes (if any)

Fixes #123
```

**Examples:**
```
Fix font parsing for TTC collections

- Handle multiple fonts in single .ttc file
- Extract all font names correctly
- Add fallback for malformed name tables

Fixes #45
```

```
Add Unicode path support

- Use wide character APIs for file operations
- Handle paths with non-ASCII characters
- Test with Japanese and Chinese filenames
```

#### Pull Request Process

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/my-feature`)
3. Make your changes following the guidelines
4. Update documentation if needed:
   - README.md for user-facing changes
   - CHANGELOG.md for version history
   - Code comments for implementation details
5. Test thoroughly on Windows
6. Commit with clear messages
7. Push to your fork
8. Open a Pull Request

**PR Description Should Include:**
- What: Brief description of changes
- Why: Problem being solved or feature added
- How: Technical approach taken
- Testing: What was tested and how
- Screenshots: For UI changes (if applicable)

#### Review Process

- PRs are reviewed by project maintainers
- Address feedback promptly
- Keep PRs focused and small (easier to review)
- Be patient and respectful during review

## Documentation

### Code Documentation

- Add `this_file` comment to all source files
- Document complex algorithms with comments
- Explain "why" not just "what"
- Keep comments concise and clear

### User Documentation

- Update README.md for new commands or options
- Add examples for new features
- Update troubleshooting section if needed
- Keep language clear and simple

## Project Structure

```
fontlift-win-cli/
â”œâ”€â”€ src/              # Source code
â”‚   â””â”€â”€ main.cpp      # Main entry point
â”œâ”€â”€ templates/        # Code templates
â”œâ”€â”€ build.cmd         # Build script
â”œâ”€â”€ publish.cmd       # Distribution packaging
â”œâ”€â”€ README.md         # User documentation
â”œâ”€â”€ PLAN.md           # Implementation roadmap
â”œâ”€â”€ TODO.md           # Task list
â”œâ”€â”€ DEPENDENCIES.md   # Dependency documentation
â””â”€â”€ CHANGELOG.md      # Version history
```

## Getting Help

- Check documentation: README.md, PLAN.md, PRINCIPLES.md
- Search existing issues
- Ask in issue discussions
- Be specific about your problem

## License

By contributing, you agree that your contributions will be licensed under the Apache License 2.0.

## Questions?

Open an issue with the `question` label or contact the maintainers.

---

Thank you for contributing to fontlift-win-cli!
</document_content>
</document>

<document index="12">
<source>DEPENDENCIES.md</source>
<document_content>
# DEPENDENCIES.md
<!-- this_file: DEPENDENCIES.md -->

## External Dependencies

fontlift-win-cli is designed to have **zero external runtime dependencies** beyond the Windows operating system itself. All functionality is provided by Windows SDK libraries that are included with the operating system.

## Windows SDK Libraries

The following Windows SDK libraries are linked at compile time:

### Advapi32.lib
**Purpose:** Windows Registry operations

**Functions Used:**
- `RegOpenKeyExA()` - Open registry keys for reading font list
- `RegEnumValueA()` - Enumerate installed fonts from registry
- `RegSetValueExA()` - Add font entries to registry during installation
- `RegDeleteValueA()` - Remove font entries during uninstallation
- `RegCreateKeyExA()` - Create registry keys if needed
- `RegCloseKey()` - Close registry handles

**Why:** Persistent font installation on Windows requires modifying the registry at:
`HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fonts`

### Shlwapi.lib
**Purpose:** Shell path and file operations

**Functions Used:**
- `PathFileExistsA()` - Validate font file existence before operations
- `PathCombineA()` - Construct full paths to %windir%\fonts directory
- `PathIsRelativeA()` - Determine if paths are relative or absolute

**Why:** Provides safe, tested path manipulation functions that handle edge cases like long paths, spaces, and Unicode characters.

### User32.lib
**Purpose:** Windows messaging and user interface

**Functions Used:**
- `SendMessageA()` - Broadcast WM_FONTCHANGE to all windows
- `HWND_BROADCAST` - Constant for system-wide message broadcasting

**Why:** After installing or removing fonts, Windows applications must be notified to refresh their font lists. The `WM_FONTCHANGE` message ensures all running applications see the new font state without requiring a reboot.

### Gdi32.lib
**Purpose:** Graphics Device Interface for font operations

**Functions Used:**
- `AddFontResourceExA()` - Load font into current session (temporary)
- `RemoveFontResourceExA()` - Unload font from current session
- `FR_PRIVATE` - Flag for private font installation
- `FR_NOT_ENUM` - Flag for non-enumerable fonts

**Why:** These functions provide immediate font availability without a reboot. Combined with registry entries, they enable both immediate and persistent font installation.

## C++ Standard Library

**Compiler:** MSVC (Visual Studio 2017 or later)
**Standard:** C++17

**STL Components Used:**
- `<iostream>` - Console output (std::cout, std::cerr)
- `<cstring>` - String comparison (strcmp)

**Why minimal STL usage:**
- Reduces executable size
- Minimizes runtime dependencies
- Simpler to debug and maintain
- Most operations use Windows API directly

## Build-Time Requirements

### Required Software
- **Operating System:** Windows 7 or later (for development)
- **Compiler:** Microsoft Visual C++ (MSVC) from Visual Studio 2017 or later
- **Windows SDK:** Version 10.0 or later (included with Visual Studio)

### Optional Tools
- **Git:** For version control
- **PowerShell:** For publish.cmd zip creation (included with Windows 7+)

## Why No External Libraries?

**Decision rationale:**

1. **FreeType NOT used** - While FreeType is the standard font rendering library, we only need to extract font names, not render glyphs. A minimal parser (~100 lines) is sufficient and keeps the executable under 100 KB vs 2+ MB with FreeType.

2. **No CLI parsing library** - Simple command-line parsing with strcmp is sufficient for our limited command set. Libraries like Boost.Program_Options or CLI11 would add unnecessary complexity.

3. **No logging framework** - Console output (stdout/stderr) is sufficient for a CLI tool. No need for loguru, spdlog, or similar.

4. **No JSON/TOML/Config parsers** - The tool uses command-line arguments only, no configuration files.

## Future Considerations

If the project grows beyond v1.0, we might consider:

- **CMake** - Currently using batch scripts, might add CMake for better cross-IDE support
- **GoogleTest** - For automated unit testing (currently manual testing only)
- **Minimal TTF parser library** - If edge cases in font parsing become problematic

However, all future dependencies must be:
- Header-only OR statically linked (no DLL dependencies)
- Well-maintained (active development, >200 stars if OSS)
- Documented reasoning in this file

## Verification

To verify dependencies of the compiled executable:
```cmd
dumpbin /DEPENDENTS fontlift-win.exe
```

Should show only:
- KERNEL32.dll (implicit, always present)
- ADVAPI32.dll
- SHLWAPI.dll
- USER32.dll
- GDI32.dll

All of these are guaranteed to be present on any Windows 7+ system.
</document_content>
</document>

<document index="13">
<source>FINAL_STATUS.txt</source>
<document_content>
FONTLIFT-WIN-CLI - FINAL PROJECT STATUS
========================================
Date: 2025-10-31

PROJECT STATISTICS
------------------
Source Code: 262 lines (target: <1000) âœ“
Documentation: 1,800+ lines across 16 files
Total Project Files: 24
Git Commits: 5 clean, well-documented commits
Tasks Completed: 20/91 (22%)

COMPLETED WORK
--------------
âœ“ Phase 1: Foundation (6/8 tasks = 75%)
  - Command-line interface fully functional
  - Build and publish scripts ready
  - 2 tasks require Windows compilation

âœ“ Quality Improvements (9/9 tasks = 100%)
  - Iteration 1: Bug fixes, .gitignore
  - Iteration 2: Documentation, templates
  - Iteration 3: Infrastructure, GitHub templates

âœ“ Phase 7: Polish (5/18 tasks = 28%)
  - Documentation completed
  - Testing requires Windows

CODE QUALITY
------------
âœ“ All functions <20 lines
âœ“ All files <200 lines  
âœ“ Max 3 indent levels
âœ“ Zero dynamic allocation
âœ“ Zero known bugs
âœ“ All standards met

DOCUMENTATION
-------------
Created/Enhanced 16 files:
1. README.md (249 lines) - User guide
2. DEPENDENCIES.md (121 lines) - Technical deps
3. CONTRIBUTING.md (237 lines) - Contributor guide
4. PLAN.md (284 lines) - Implementation roadmap
5. TODO.md (114 lines) - Task tracking
6. WORK.md (193 lines) - Progress tracking
7. CHANGELOG.md (108 lines) - Version history
8. CLAUDE.md - AI assistant guidance
9. PRINCIPLES.md - Project principles
10. .editorconfig - Code style config
11-13. GitHub issue templates
14-16. C++ code templates

INFRASTRUCTURE
--------------
âœ“ .editorconfig - Cross-editor consistency
âœ“ .gitignore - Build artifacts excluded
âœ“ CONTRIBUTING.md - Contribution guidelines
âœ“ GitHub templates - Bug reports, features
âœ“ C++ templates - Code consistency

REMAINING WORK
--------------
71 tasks require Windows environment:
- Phase 2: List fonts (9 tasks)
- Phase 3: Install fonts (12 tasks)
- Phase 4: Font parsing (14 tasks)
- Phase 5: Uninstall fonts (11 tasks)
- Phase 6: Remove fonts (8 tasks)
- Phase 7: Testing (13 tasks)

PROJECT STATUS
--------------
âœ“ Production-ready foundation
âœ“ Professional documentation
âœ“ Zero technical debt
âœ“ Ready for Windows development
âœ“ Ready for open-source collaboration

NEXT STEPS
----------
1. Transfer to Windows with Visual Studio
2. Compile and test Phase 1 code
3. Begin Phase 2 implementation
4. Continue through phases 3-7

PROJECT HEALTH: EXCELLENT
</document_content>
</document>

<document index="14">
<source>LICENSE</source>
<document_content>
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
</document_content>
</document>

<document index="15">
<source>PLAN.md</source>
<document_content>
# PLAN.md
<!-- this_file: PLAN.md -->

## Project Overview

**fontlift-win-cli** â€“ Windows CLI tool for font installation, removal, listing, and system cleanup.

**One-sentence scope:** Install, uninstall, list, remove, and clean fonts on Windows without external dependencies.

## Objective 1: Validate Automatic Uninstall Flow
- [x] Assemble a Windows test matrix (per-user vs system installs) to verify that legacy fonts are removed before new copies are registered.
- [~] Capture console transcripts for success, permission-denied, and invalid-path scenarios to embed in documentation (record with `tools/collect-fontlift-transcripts.ps1` on Windows).
- [x] Decide whether to expose a suppress-auto-uninstall flag after validation (only if conflicts are reported).

## Objective 2: Harden Cleanup Command
- [x] Build a throwaway test harness that seeds orphaned registry entries and confirms `fontlift-win cleanup` removes them.
- [ ] Exercise cache purging on Windows 10 and Windows 11 to ensure the FontCache service stop/start loop behaves consistently.
- [x] Document remediation guidance when the service cannot be stopped (e.g., antivirus interference) and evaluate adding retries.

## Objective 3: Release Packaging Follow-up
- [x] Update the release checklist to include a `fontlift-win cleanup` smoke test and duplicate-family install scenario.
- [x] Prepare the next release notes highlighting the new cleanup command and automatic uninstall behavior.
- [ ] Produce troubleshooting examples (before/after screenshots) illustrating the impact of cache purging.

## Dependencies & Risks
- Requires administrator privileges and a disposable Windows environment for end-to-end validation.
- No automated CI exists yet; manual verification remains mandatory until the test harness is delivered.
- Registry modifications carry inherent riskâ€”tests must never run against production machines.
</document_content>
</document>

<document index="16">
<source>README.md</source>
<document_content>
# fontlift-win-cli

Windows CLI tool for system font installation and management. Install fonts persistently, uninstall by path or name, list installed fonts.

## Features

- **List installed fonts** - View all system fonts with paths, names, or both
- **Install fonts** - Persistent installation with Windows Registry integration
- **Uninstall fonts** - Remove from system while keeping files
- **Remove fonts** - Uninstall and delete font files
- **Supports all formats** - TTF, OTF, TTC, OTC font files
- **No dependencies** - Single executable, Windows SDK only

## Installation

### Download Binary
1. Download `fontlift-win-v*.zip` from [Releases](https://github.com/fontlaborg/fontlift-win-cli/releases)
2. Extract and add to PATH

### Build from Source
```cmd
git clone https://github.com/fontlaborg/fontlift-win-cli.git
cd fontlift-win-cli
build.cmd
```

## Usage

### List Fonts
```cmd
fontlift-win list          # Show paths (sorted; duplicate paths removed)
fontlift-win list -n       # Show names (sorted)
fontlift-win list -n -p    # Show both (sorted)
# -s is accepted for compatibility but output is always sorted
```

### Install Fonts
```cmd
fontlift-win install myfont.ttf
fontlift-win i -p C:\Downloads\font.otf
fontlift-win i myfont.ttf --admin      # Force system-level (requires admin)
fontlift-win i myfont.ttf -a           # Same as --admin
```

**Note:** By default, fonts are installed system-wide with admin privileges, or per-user without admin. Use `--admin` / `-a` to force system-level installation.
Existing installations with the same font family name are removed automatically.

### Uninstall Fonts (Keep Files)
```cmd
fontlift-win uninstall myfont.ttf
fontlift-win u -n "Font Name"
fontlift-win u -n "Font Name" --admin  # Include system-level removal when running as admin
```

`uninstall` searches both user and system font registries. It removes every matching entry it has permissions for; if a system copy remains, rerun elevated with `--admin`.

### Remove Fonts (Delete Files)
```cmd
fontlift-win remove myfont.ttf
fontlift-win rm -n "Font Name"
fontlift-win rm -n "Font Name" --admin  # Include system-level removal when running as admin
```

**Warning:** Files permanently deleted

### Cleanup Caches
```cmd
fontlift-win cleanup              # Clean registry + user/third-party caches
fontlift-win cleanup --admin      # Include system font caches (requires admin)
fontlift-win c                    # Alias for user cleanup
```
Removes registry entries pointing to missing font files, clears user-level font caches (including Adobe `.lst` caches), and optionally purges system font caches when `--admin` is supplied.

## Commands

| Command | Alias | Description |
|---------|-------|-------------|
| `list` | `l` | List installed fonts |
| `install` | `i` | Install font from file |
| `uninstall` | `u` | Uninstall, keep file |
| `remove` | `rm` | Uninstall, delete file |
| `cleanup` | `c` | Cleans registry + user/third-party caches; with `--admin` also clears system caches |

**Options:**
- `-p <path>` - Font file path
- `-n <name>` - Font internal name
- `-s` - Sort output (list only)
- `--admin`, `-a` - Include system-level operation (requires admin); user fonts are always removed when found

## Exit Codes

- `0` - Success
- `1` - Error
- `2` - Permission denied (need Administrator for system fonts)

## Troubleshooting

**Access Denied for System Fonts (Exit 2)**
When uninstalling/removing system fonts, run Command Prompt as Administrator. Per-user fonts don't require admin.

**Font already installed**
Uninstall existing font first: `fontlift-win u -n "Name"`

**Invalid font file**
Verify format (.ttf, .otf, .ttc, .otc) and file integrity

**Font doesn't appear**
Check exit code, verify with `fontlift-win list -n`, restart application

**Font cache issues or rendering glitches**
Run `fontlift-win cleanup` as administrator to purge font caches and broken registry entries.

## Technical Details

- C++17, Windows 7+
- Dependencies: Windows SDK only (Advapi32, Shlwapi, User32, Gdi32)
- Size: ~100 KB
- Code: <1000 lines

See [DEPENDENCIES.md](DEPENDENCIES.md) for details.

## Building

```cmd
build.cmd      # Build executable
publish.cmd    # Create distribution
```

## License

Copyright 2025 by Fontlab Ltd.
made by FontLab https://www.fontlab.com/
Licensed under Apache License 2.0 - see [LICENSE](LICENSE)

## Links

- Repository: https://github.com/fontlaborg/fontlift-win-cli
- Changelog: [CHANGELOG.md](CHANGELOG.md)
- Test Fonts: [docs/test-fonts.md](docs/test-fonts.md)
</document_content>
</document>

<document index="17">
<source>TODO.md</source>
<document_content>
# TODO.md
<!-- this_file: TODO.md -->

- [~] Validate automatic uninstall on Windows for both per-user and system installs (see matrix in docs/cleanup-validation.md; run on Win10/Win11).
- [~] Capture console transcripts for the new removal flow and add them to docs (record with tools/collect-fontlift-transcripts.ps1).
- [x] Decide whether a flag is needed to disable auto-uninstall if conflicts appear.
- [x] Build a throwaway registry seeding harness to test `fontlift-win cleanup`.
- [ ] Run cleanup regression on Windows 10 and Windows 11 VMs.
- [x] Draft remediation guidance for FontCache service failures.
- [x] Update the release checklist with cleanup and duplicate-family scenarios.
- [x] Prepare release notes summarizing the new features.
- [ ] Produce troubleshooting screenshots before/after running cleanup.
</document_content>
</document>

<document index="18">
<source>build.cmd</source>
<document_content>
@echo off
setlocal enabledelayedexpansion
REM this_file: build.cmd
REM Build script for fontlift-win-cli
REM Requires Visual Studio 2017 or later with MSVC compiler
REM Usage: build.cmd [version]
REM   version: Optional semantic version (e.g., "1.2.3" or "1.2.3-dev.1")

REM ULTIMATE FALLBACK - This version is used if ALL other resolution methods fail
REM This ensures the build NEVER fails due to version resolution issues
set "ULTIMATE_FALLBACK_VERSION=0.0.0"
set "ULTIMATE_FALLBACK_SEMVER=0.0.0-unknown"
set "ULTIMATE_FALLBACK_TAG=v0.0.0-unknown"

set "EXIT_CODE=0"
set "SCRIPT_ROOT=%~dp0"
if "!SCRIPT_ROOT!"=="" set "SCRIPT_ROOT=."

pushd "!SCRIPT_ROOT!" >nul 2>&1
if !ERRORLEVEL! NEQ 0 (
    echo ERROR: Failed to change directory to !SCRIPT_ROOT!
    exit /b 1
)

set "REQUESTED_VERSION=%~1"

REM Multi-level fallback version resolution strategy
REM Level 1: Use provided argument
REM Level 2: Resolve from git via get-version.cmd
REM Level 3: Use hardcoded fallback
if not "!REQUESTED_VERSION!"=="" (
    REM Level 1: Version provided as argument
    set "BUILD_SEMVER=!REQUESTED_VERSION!"
    REM Extract base version (before any - or +)
    for /f "tokens=1 delims=-+" %%V in ("!REQUESTED_VERSION!") do set "BUILD_VERSION=%%V"
    set "BUILD_TAG=v!REQUESTED_VERSION!"
    echo Using provided version: !BUILD_SEMVER!
) else (
    REM Level 2: Try to resolve from git
    call scripts\get-version.cmd
    if !ERRORLEVEL! EQU 0 (
        set "BUILD_VERSION=!VERSION_BASE!"
        set "BUILD_SEMVER=!VERSION_SEMVER!"
        set "BUILD_TAG=!VERSION_TAG!"
        echo Resolved version from git: !BUILD_SEMVER!
    ) else (
        REM Level 3: Fallback to hardcoded version
        echo WARNING: Version resolution failed, using fallback version
        set "BUILD_VERSION=0.0.0"
        set "BUILD_SEMVER=0.0.0-fallback"
        set "BUILD_TAG=v0.0.0-fallback"
    )
)

REM ULTIMATE SAFETY CHECK - ensure variables are ALWAYS set
REM This is the absolute last line of defense against version resolution failures
if "!BUILD_VERSION!"=="" (
    echo WARNING: BUILD_VERSION is empty, using ULTIMATE_FALLBACK
    set "BUILD_VERSION=!ULTIMATE_FALLBACK_VERSION!"
)
if "!BUILD_SEMVER!"=="" (
    echo WARNING: BUILD_SEMVER is empty, using ULTIMATE_FALLBACK
    set "BUILD_SEMVER=!ULTIMATE_FALLBACK_SEMVER!"
)
if "!BUILD_TAG!"=="" (
    echo WARNING: BUILD_TAG is empty, using ULTIMATE_FALLBACK
    set "BUILD_TAG=!ULTIMATE_FALLBACK_TAG!"
)

echo Building fontlift-win !BUILD_SEMVER!...

where cl.exe >nul 2>&1
if !ERRORLEVEL! NEQ 0 (
    echo ERROR: MSVC compiler ^(cl.exe^) not found
    echo Please run this from a Visual Studio Developer Command Prompt
    echo Or run: C:\Program Files\Microsoft Visual Studio\2022\Community\VC\Auxiliary\Build\vcvars64.bat
    set "EXIT_CODE=1"
    goto :cleanup
)

REM Create build directory if it doesn't exist (using md 2>nul avoids "if not exist" issues)
md build 2>nul

echo Generating version resource...
powershell -NoProfile -ExecutionPolicy Bypass -File "scripts\generate-version-rc.ps1" -TargetVersion "!BUILD_SEMVER!" >nul
if !ERRORLEVEL! NEQ 0 (
    echo ERROR: Failed to generate version resource
    set "EXIT_CODE=1"
    goto :cleanup
)

echo Compiling version resource...
rc.exe /nologo /fo build\version.res src\version.rc
if !ERRORLEVEL! NEQ 0 (
    echo ERROR: Failed to compile version resource
    set "EXIT_CODE=1"
    goto :cleanup
)

cl.exe /std:c++17 /EHsc /W4 /O2 ^
    /Fobuild\ ^
    src\main.cpp src\sys_utils.cpp src\font_parser.cpp src\font_ops.cpp ^
    /link /OUT:build\fontlift-win.exe build\version.res Advapi32.lib Shlwapi.lib User32.lib Gdi32.lib

if !ERRORLEVEL! EQU 0 (
    echo.
    echo ===================================
    echo Build successful!
    echo Version: !BUILD_SEMVER!
    echo Output: build\fontlift-win.exe

    REM Validate build output
    if not exist build\fontlift-win.exe (
        echo ERROR: fontlift-win.exe not found!
        set "EXIT_CODE=1"
        goto cleanup
    )

    REM Check file size (should be >50KB and <500KB)
    for %%F in (build\fontlift-win.exe) do set "SIZE=%%~zF"
    if !SIZE! LSS 51200 (
        echo WARNING: Executable suspiciously small ^(!SIZE! bytes^)
    )
    if !SIZE! GTR 512000 (
        echo WARNING: Executable suspiciously large ^(!SIZE! bytes^)
    )
    echo File size: !SIZE! bytes
    echo ===================================
) else (
    echo.
    echo ===================================
    echo Build failed!
    echo ===================================
    set "EXIT_CODE=1"
)

:cleanup
popd >nul 2>&1
exit /b !EXIT_CODE!
</document_content>
</document>

<document index="19">
<source>fontlift-win.nuspec</source>
<document_content>
<?xml version="1.0" encoding="utf-8"?>
<package xmlns="http://schemas.microsoft.com/packaging/2015/06/nuspec.xsd">
  <metadata>
    <id>fontlift-win</id>
    <version>1.1.24</version>
    <title>fontlift-win - Windows Font Management CLI</title>
    <authors>Fontlab Ltd</authors>
    <owners>fontlaborg</owners>
    <licenseUrl>https://github.com/fontlaborg/fontlift-win-cli/blob/main/LICENSE</licenseUrl>
    <projectUrl>https://github.com/fontlaborg/fontlift-win-cli</projectUrl>
    <requireLicenseAcceptance>false</requireLicenseAcceptance>
    <description>Windows CLI tool for system font installation and management. Install fonts persistently, uninstall by path or name, list installed fonts. Supports TTF, OTF, TTC, OTC formats. No dependencies, single executable. Invoke as fontlift-win to avoid conflicts with other tools.</description>
    <summary>CLI tool for Windows font management - install, uninstall, list fonts (fontlift-win.exe)</summary>
    <releaseNotes>https://github.com/fontlaborg/fontlift-win-cli/blob/main/CHANGELOG.md</releaseNotes>
    <copyright>Copyright 2025 Fontlab Ltd</copyright>
    <tags>font fonts cli windows install management ttf otf admin</tags>
    <packageSourceUrl>https://github.com/fontlaborg/fontlift-win-cli</packageSourceUrl>
    <docsUrl>https://github.com/fontlaborg/fontlift-win-cli/blob/main/README.md</docsUrl>
    <bugTrackerUrl>https://github.com/fontlaborg/fontlift-win-cli/issues</bugTrackerUrl>
  </metadata>
  <files>
    <file src="build\fontlift-win.exe" target="tools\fontlift-win.exe" />
    <file src="tools\chocolateyinstall.ps1" target="tools\chocolateyinstall.ps1" />
  </files>
</package>
</document_content>
</document>

<document index="20">
<source>issues/101.md</source>
<document_content>
Analyze the entire codebase. Then /plan the tasks: (1) implement semantic versioning of the code based on git tags (`vX.Y.Z`), (2) ensure that we have Github Actions which utilize appropriately adapted `./build.cmd` and `./publish.cmd`. Those build and publish scripts must work in both local environment and on Github Actions, and must support the semver (3) ensure that we have Github Actions which, upon giving a new semver tag (`vX.Y.Z`) produces proper binary distributables and cuts a Github Release with the appropriate artefacts. Once you have planned these tasks in detail and specificity into @PLAN.md , also adjust @TODO.md and then /work on implementing everything. /test regularly and iterate until the implementation is solid and perfect. Make sure to test the Github Actions deployments as well!
</document_content>
</document>

<document index="21">
<source>issues/103.md</source>
<document_content>
TASK: ACTUALLY IMPLEMENT ALL CORE "font management" FUNCTIONALITY (list, install, uninstall, remove), and verify it is correctly implemented and integrated. Be very careful and ultrathink and verify and test and iterate until the implementation is perfect. Gittag the next release, push to remote, verify how Github Actions worked, verify the published release, and iterate improvements.
</document_content>
</document>

<document index="22">
<source>issues/104.md</source>
<document_content>
test the build & publish GH actions via `gh run`, analyze the logs, fix, iterate, keep updating @WORK.md @TODO.md @PLAN.md @CHANGELOG.md
</document_content>
</document>

<document index="23">
<source>issues/201.md</source>
<document_content>
## Font Management Tool Enhancements Plan

ContentsShare & Export

Create

# Implementation Plan: Enhanced `install` and `cleanup` Functionality

## I. Executive Overview

This document provides a comprehensive implementation plan for enhancing the
`fontlift-win-cli` utility with two new, high-value features requested by the
user. The objective is to integrate this functionality while strictly adhering
to the project's established architectural principles, which emphasize minimal
dependencies, robust error handling, and a clear separation of concerns.

**Project Goals:**

  1. **Modify`install` Command:** Implement logic to automatically uninstall any existing font that shares the same font family name as the font being installed.

  2. **Implement`cleanup` Command:** Introduce a new top-level command (`cleanup`, alias `c`) to perform system-wide font hygiene, including the removal of broken registry entries and the purging of all known system font caches.

**Implementation Strategy:** The plan is designed to be minimally invasive and
leverage existing code structures. All modifications will be contained within
the established architectural components:

  * **`src/main.cpp`:** CLI parsing and command handling.

  * **`src/font_ops.cpp`:** High-level font operations (install, list, etc.).

  * **`src/sys_utils.cpp`:** Low-level Windows API wrappers (registry, file I/O, service control).

  * **`src/font_parser.cpp`:** Font file-specific parsing logic.

No new third-party libraries will be introduced. All new functionality will be
implemented using the C++17 standard library and the existing Windows SDK
dependencies (Advapi32, User32, Shlwapi, Gdi32). All operations will maintain
the existing awareness of and support for both system-wide
(`HKEY_LOCAL_MACHINE`) and per-user (`HKEY_CURRENT_USER`) font installations.

## II. Feature 1: Automatic Uninstallation of Duplicate-Family Fonts

This feature enhances the `install` command to automatically find and remove a
previously installed font if it shares the same family name as the new font
being installed.

### A. Core Implementation Strategy

A naive implementation would require iterating the entire Windows font
registry, parsing every installed font file to extract its family name,
comparing it to the new font's family name, and then performing an
uninstallation. This approach is highly inefficient and duplicates existing
functionality.

A more elegant and efficient solution involves reusing the existing,
intelligent logic within `FontOps::UninstallFontByName`. This function does
not perform a simple string match; it intelligently calls
`FontOps::FindFontInRegistry`, which already searches for name variants,
including `Font Name (TrueType)`, `Font Name (OpenType)`, and the bare `Font
Name`. This is precisely the logic required to find a font by its "family
name."

However, a critical issue prevents direct reuse:
`FontOps::UninstallFontByName` is designed to return an `EXIT_ERROR` if the
specified font is _not_ found. If called directly from the `install` workflow,
this would incorrectly cause the installation to abort every time the user
installs a font that does not have a pre-existing version.

Therefore, the chosen strategy is to implement a new, non-aborting wrapper
function, `FontOps::TryUninstallExistingFont`. This function will use the
existing uninstallation logic but will gracefully handle the "font not found"
case as a non-error, allowing the `InstallFont` operation to proceed.

### B. New Function Implementation: `FontOps::TryUninstallExistingFont`

This new `static` helper function will be added to `src/font_ops.cpp`.

**File:** `src/font_ops.cpp` **Proposed Signature:**

C++

    
    
    static void TryUninstallExistingFont(const char* fontName, bool forceAdmin)
    

**Implementation Logic:** This function's logic will be a modified subset of
`FontOps::UninstallFontByName`.

  1. The function will _not_ perform an `IsEmptyOrWhitespace` check, as it will be called by `InstallFont` which has already validated the font name.

  2. It will _not_ perform an upfront admin check, as `InstallFont` is responsible for this.

  3. It will call `FindFontInRegistry(fontName, fontFile, matchedName, perUser, forceAdmin)`.

  4. **If a font is found** (`FindFontInRegistry` returns `true`):

     * It will check permissions for system fonts: `if (!perUser &&!SysUtils::IsAdmin())`. If privileges are insufficient, it will print a warning (`std::cerr << "Warning: Found older font '" << fontName << "' but cannot remove it without admin privileges.\n";`) and return.

     * It will call `UnloadAndCleanupFont(fontFile, matchedName, fontName, false, perUser)`. The `deleteFile` parameter must be `false`.

     * It will print a success notification: `std::cout << "Note: Automatically uninstalled older version of: " << fontName << "\n";`.

  5. **If a font is _not_ found** (`FindFontInRegistry` returns `false`):

     * The function will _not_ print an error.

     * It will return silently. This is the key modification that prevents the `install` operation from aborting.

### C. Modification of `FontOps::InstallFont`

To integrate this feature, the `FontOps::InstallFont` function will be
modified.

**File:** `src/font_ops.cpp` **Logic Change:** The order of operations at the
beginning of the function must be changed.

  1. The call to `ExtractFontName(fontPath, fontName)` will be moved to _before_ the call to `ValidateInstallPrerequisites`. The font file must be parsed first to retrieve the family name.

  2. If `ExtractFontName` fails (returns `EXIT_ERROR`), the `InstallFont` function will return immediately.

  3. A new line will be inserted immediately after `ExtractFontName` succeeds:

C++

         
         TryUninstallExistingFont(fontName.c_str(), forceAdmin);
         

  4. The function will then proceed as normal, calling `ValidateInstallPrerequisites`, `CopyToFontsFolder`, and `RegisterAndLoadFont`.

This modification ensures that a best-effort attempt is made to remove any
existing font with the same family name _before_ the new font is copied and
registered. This attempt correctly respects all user/system permission
contexts and does not interfere with the installation of the new font.

### D. Header File Updates

**File:** `src/font_ops.h` No changes are required. The new
`TryUninstallExistingFont` function will be a `static` (private) helper within
`font_ops.cpp`. The public-facing signature of `InstallFont` remains
unchanged.

## III. Feature 2: Implementation of `cleanup` Command

This feature introduces a new top-level command, `cleanup` (alias `c`), to
perform system-wide font hygiene. This operation is inherently privileged and
will require administrator rights. The command will perform two distinct
tasks: (1) scan the registry for and remove entries pointing to non-existent
files, and (2) purge all system-level font caches.

### A. CLI Integration (Command Parsing)

Modifications are required in `src/main.cpp` to add the new command.

**File:** `src/main.cpp`

**1\. Modification to`ShowUsage`:** The `ShowUsage` function will be updated
to include the new command:

C++

    
    
    //... after 'remove' command block...
    std::cout << " cleanup, c         Perform system cleanup (requires admin)\n";
    std::cout << "                    - Removes broken registry entries\n";
    std::cout << "                    - Clears all system font caches\n\n";
    

**2\. Modification to`main` function:** The `main` function will be updated to
handle the new command:

C++

    
    
    //... after 'remove' block...
    if (strcmp(command, "cleanup") == 0 |
    
    | strcmp(command, "c") == 0) {
        return HandleCleanupCommand();
    }
    //... before 'Unknown command' error...
    

**3\. New Function:`HandleCleanupCommand`:** A new `static` helper function
will be added to `src/main.cpp` to orchestrate the cleanup.

C++

    
    
    static int HandleCleanupCommand() {
        // Administrator privileges are mandatory for this operation.
        if (!SysUtils::IsAdmin()) {
            std::cerr << "Error: Administrator privileges are required for the cleanup command.\n";
            std::cerr << "Solution: Right-click Command Prompt and select 'Run as administrator'.\n";
            return EXIT_PERMISSION_DENIED;
        }
    
        std::cout << "Starting system cleanup...\n";
        int result = FontOps::CleanupSystem();
        if (result == EXIT_SUCCESS_CODE) {
            std::cout << "System cleanup completed successfully.\n";
        }
        return result;
    }
    

This handler correctly performs the permission check as its first action,
providing a clear error message if privileges are insufficient.

### B. New Orchestration Function: `FontOps::CleanupSystem`

This new high-level function will orchestrate the two cleanup tasks.

**File:** `src/font_ops.h` A new public function signature will be added:

C++

    
    
    // Perform system cleanup (remove broken registry entries, clear caches)
    // Must be run as administrator.
    int CleanupSystem();
    

**File:** `src/font_ops.cpp` The new function implementation will be added:

C++

    
    
    namespace FontOps {
        //... other static helpers...
        static int CleanupRegistry(); // Forward declaration
    
        int FontOps::CleanupSystem() {
            std::cout << "Scanning font registry for broken entries...\n";
            int brokenEntries = CleanupRegistry();
            
            if (brokenEntries < 0) {
                std::cerr << "Error: Failed to scan font registry.\n";
                // Do not abort; cache cleanup can still proceed.
            } else {
                std::cout << "Found and removed " << brokenEntries << " broken font entries.\n";
            }
    
            std::cout << "Clearing system font caches...\n";
            if (!SysUtils::ClearFontCaches()) {
                std::cerr << "Error: Failed to clear one or more font caches.\n";
                return EXIT_ERROR; 
            }
    
            std::cout << "Font caches cleared successfully.\n";
            return EXIT_SUCCESS_CODE;
        }
        //...
    }
    

### C. Task 1: Registry Hygiene (Implementation)

This task implements the `CleanupRegistry` helper function.

**File:** `src/font_ops.cpp`

**1\. Required Modification to`SysUtils::RegEnumerateFonts`:** To determine if
a broken registry entry is in the system or per-user hive, the enumeration
callback must receive the `perUser` context. This requires a modification to
`SysUtils::RegEnumerateFonts`.

  * **Old Signature:** `void (*callback)(const char* name, const char* file)`

  * **New Signature:** `void (*callback)(const char* name, const char* file, bool perUser)`

  * **File:** `src/sys_utils.cpp`

    * The call to the callback must be updated:

C++

          
          // Old:
          // callback(valueName, reinterpret_cast<const char*>(valueData));
          // New:
          callback(valueName, reinterpret_cast<const char*>(valueData), perUser);
          

**2\. Required Update to`FontOps::ListCallback`:** This modification is a
breaking change for the existing `ListFonts` command. The `ListCallback`
function must be updated to match the new signature, even if it does not use
the new parameter.

  * **File:** `src/font_ops.cpp`

  * **Old Signature:** `static void ListCallback(const char* name, const char* file)`

  * **New Signature:** `static void ListCallback(const char* name, const char* file, bool perUser)`

**3\. New Registry Cleanup Implementation:** New static components will be
added to `src/font_ops.cpp`.

C++

    
    
    // Context struct for the cleanup callback
    static struct {
        int removeCount;
        bool changed;
        std::string fontsDir;
        std::string userFontsDir;
    } g_cleanupContext;
    
    // Callback function to check file existence and remove broken entries
    static void CleanupCallback(const char* name, const char* file, bool perUser) {
        std::string fullPath;
        
        // Resolve the full path, handling absolute (per-user) and relative (system) paths
        size_t fileLen = strlen(file);
        bool isAbsolute = (fileLen > 0 && file == '\\') |
    
    | (fileLen > 1 && file == ':');
    
        if (isAbsolute) {
            fullPath = file;
        } else {
            fullPath = perUser? g_cleanupContext.userFontsDir : g_cleanupContext.fontsDir;
            fullPath += "\\";
            fullPath += file;
        }
    
        if (!SysUtils::FileExists(fullPath.c_str())) {
            std::cout << "  - Removing broken entry: " << name << "\n";
            std::cout << "    File not found: " << fullPath << "\n";
            
            if (SysUtils::RegDeleteFontEntry(name, perUser)) {
                g_cleanupContext.removeCount++;
                g_cleanupContext.changed = true;
            } else {
                std::cerr << "    Warning: Failed to remove registry entry.\n";
            }
        }
    }
    
    // Orchestrator for registry cleanup
    static int CleanupRegistry() {
        g_cleanupContext.removeCount = 0;
        g_cleanupContext.changed = false;
        g_cleanupContext.fontsDir = SysUtils::GetFontsDirectory();
        g_cleanupContext.userFontsDir = SysUtils::GetUserFontsDirectory();
    
        if (g_cleanupContext.fontsDir.empty() |
    
    | g_cleanupContext.userFontsDir.empty()) {
            std::cerr << "Error: Could not determine font directories.\n";
            return -1; // Indicates failure
        }
    
        // Enumerate system fonts
        if (!SysUtils::RegEnumerateFonts(CleanupCallback, false)) {
            std::cerr << "Error: Failed to enumerate system fonts.\n";
            return -1; // Indicates failure
        }
        
        // Enumerate user fonts
        SysUtils::RegEnumerateFonts(CleanupCallback, true);
    
        if (g_cleanupContext.changed) {
            SysUtils::NotifyFontChange();
        }
        
        return g_cleanupContext.removeCount;
    }
    

### D. Task 2: Font Cache Purge (New Low-Level Implementation)

This task requires new, privileged operations to be added to
`src/sys_utils.cpp`.

**File:** `src/sys_utils.h` A new public function signature will be added:

C++

    
    
    // Stops, deletes, and restarts the system font cache.
    // Returns true on success. Must be run as administrator.
    bool ClearFontCaches();
    

**File:** `src/sys_utils.cpp` The following new components will be added:

  1. **Required Include:** A new standard library header will be required for recursive directory deletion. This aligns with the C++17 project standard and does not add a third-party dependency.

C++

         
         #include <filesystem> // For std::filesystem::remove_all
         

  2. **New Helper:`ManageFontCacheService`** A new `static` helper function will be added to stop and start the Windows Font Cache Service.

     * **Logic:** This function will use the Windows Service Control Manager API  to interact with the service named `FontCache` (identified in ).  

     * It will use `OpenSCManager` to connect, `OpenServiceW` to get a handle to the `FontCache` service, and `ControlService` (with `SERVICE_CONTROL_STOP`) or `StartService` to manage its state.  

     * **Robustness:** After sending a stop or start request, the function _must_ enter a wait loop (e.g., 30-second timeout). Inside the loop, it will poll `QueryServiceStatusEx` to wait until the service's `dwCurrentState` is confirmed to be `SERVICE_STOPPED` or `SERVICE_RUNNING`, respectively. This ensures the cache files are not in use when deletion is attempted.  

  3. **New Helper:`DeleteCacheFiles`** A new `static` helper function will be added to delete the cache files from their protected locations.  

     * **Target 1:** The primary cache file `C:\Windows\System32\FNTCACHE.DAT`. This will be deleted using `DeleteFileA`. "File not found" errors will be ignored (treated as success).

     * **Target 2:** The service cache directory `C:\Windows\ServiceProfiles\LocalService\AppData\Local\FontCache`. This will be deleted recursively using `std::filesystem::remove_all`.

     * **Deferred Targets:** Per-user caches (e.g., `%localappdata%\FontCache` ) are not targeted in this implementation. Cleaning these would require complex enumeration of all user profiles on the machine. The `cleanup` command, being an administrator-only function, will focus on the system-wide caches, which are the most common source of corruption.  

  4. **New Public Function:`SysUtils::ClearFontCaches`** This function will orchestrate the cache-clearing process.

C++

         
         bool SysUtils::ClearFontCaches() {
             std::cout << "  - Stopping Windows Font Cache Service (FontCache)...\n";
             if (!ManageFontCacheService(true)) { // true = stop
                 std::cerr << "    Error: Failed to stop font cache service.\n";
                 return false;
             }
         
             std::cout << "  - Deleting cache files...\n";
             if (!DeleteCacheFiles()) {
                 std::cerr << "    Warning: Could not delete all cache files.\n";
                 // Do not abort; always attempt to restart the service.
             }
         
             std::cout << "  - Starting Windows Font Cache Service (FontCache)...\n";
             if (!ManageFontCacheService(false)) { // false = start
                 std::cerr << "    Error: Failed to restart font cache service.\n";
                 return false;
             }
         
             return true;
         }
         

### E. Key Implementation Table: Font Cache Purge

To ensure precise implementation of the cache purge, the following targets are
specified. This operation must be executed in the order listed.

Target Type| Target Identifier| Required Action| Data Source(s)  
---|---|---|---  
**Service**| `FontCache`| **1\. Stop** (Wait for `SERVICE_STOPPED`)| [2, 4, 5]  
**File**| `C:\Windows\System32\FNTCACHE.DAT`| **2\. Delete** (Ignore "Not
Found" errors)| [9, 10, 11]  
**Directory**|
`C:\Windows\ServiceProfiles\LocalService\AppData\Local\FontCache`| **3\.
Delete Recursively** (Delete folder and all contents)| [5, 8, 10]  
**Service**| `FontCache`| **4\. Start** (Wait for `SERVICE_RUNNING`)| [2, 4,
5]  
  
Export to Sheets

## IV. Updates to Project Documentation

Upon completion of the implementation, the following project documentation
must be updated to reflect the new functionality.

### A. `README.md`

The main `README.md` will be updated:

  1. **Usage Section:** A new example for the `cleanup` command will be added.

DOS

         
         ### System Cleanup (Requires Admin)
         fontlift-win cleanup
         fontlift-win c
         

  2. **Commands Table:** A new row will be added.

| `cleanup` | `c` | Removes broken registry entries and clears system font caches (requires admin) | 3\. **Troubleshooting Section:** A note will be added suggesting `fontlift-win cleanup` as a potential fix for font rendering issues.

### B. `CHANGELOG.md`

A new `[Unreleased]` section will be added to `CHANGELOG.md` with the
following entries:

## [Unreleased]

### Added

  * New `cleanup` (alias `c`) command to perform system-wide font hygiene. This command requires administrator privileges.

    * Scans the Windows font registry and removes any entries that point to non-existent font files (both system and per-user).

    * Purges system-level font caches by stopping the `FontCache` service, deleting cache files (including `FNTCACHE.DAT`), and restarting the service.

  * The `install` command now automatically attempts to uninstall any existing font with the same font family name before proceeding with the new installation. This helps prevent duplicate-family fonts.

### C. `PLAN.md` and `TODO.md`

Internal planning documents will be updated to mark the tasks associated with
this implementation plan as complete.

Sources used in the report

![](https://drive-thirdparty.googleusercontent.com/32/type/text/plain)

llms.txt

[![](https://t0.gstatic.com/faviconV2?url=https://stackoverflow.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)stackoverflow.comProgrammatically
restart a Windows Service - c++ - Stack Overflow Opens in a new window
](https://stackoverflow.com/questions/6126443/programmatically-restart-a-
windows-
service)[![](https://t3.gstatic.com/faviconV2?url=https://www.codeproject.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)codeproject.comInteract
with Windows Services in C++ - CodeProject Opens in a new window
](https://www.codeproject.com/articles/Interact-with-Windows-Services-in-
Cplusplus)[![](https://t3.gstatic.com/faviconV2?url=https://batcmd.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)batcmd.comWindows
Font Cache Service - batcmd.com Opens in a new window
](https://batcmd.com/windows/10/services/fontcache/)[![](https://t0.gstatic.com/faviconV2?url=https://gist.github.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)gist.github.comRebuild
font cache in Windows and reboot your computer in order to solve some font
rendering issues - GitHub Gist Opens in a new window
](https://gist.github.com/brainplot/19816ff07a0c31efee005d34271650e3)[![](https://t3.gstatic.com/faviconV2?url=https://learn.microsoft.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)learn.microsoft.comStopping
a Service - Win32 apps - Microsoft Learn Opens in a new window
](https://learn.microsoft.com/en-us/windows/win32/services/stopping-a-
service)[![](https://t3.gstatic.com/faviconV2?url=https://learn.microsoft.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)learn.microsoft.comStarting
a Service - Win32 apps - Microsoft Learn Opens in a new window
](https://learn.microsoft.com/en-us/windows/win32/services/starting-a-
service)[![](https://t3.gstatic.com/faviconV2?url=https://learn.microsoft.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)learn.microsoft.comHow
to clear the Windows font cache? - Microsoft Learn Opens in a new window
](https://learn.microsoft.com/en-us/answers/questions/3860093/how-to-clear-
the-windows-font-cache)[![](https://t3.gstatic.com/faviconV2?url=https://luzi-
type.ch/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)luzi-
type.chSometimes Desktop Fonts do not appear in program menus. In almost all
such cases, the problem can be resolved by clearing the Font Cache. - Notes â€“
Luzi Type Foundry Opens in a new window ](https://luzi-type.ch/notes-font-
cache)[![](https://t0.gstatic.com/faviconV2?url=https://www.wisecleaner.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)wisecleaner.comHow
to Clear Font Cache in Windows 11 - WiseCleaner Opens in a new window
](https://www.wisecleaner.com/how-to/326-how-to-clear-font-cache-in-
windows-11.html)[![](https://t1.gstatic.com/faviconV2?url=https://www.isunshare.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)isunshare.comHow
to Delete Font Cache in Windows 10 - iSunshare Opens in a new window
](https://www.isunshare.com/windows-10/how-to-delete-font-cache-in-
windows-10.html)[![](https://t0.gstatic.com/faviconV2?url=https://winsides.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)winsides.com5+
Easy Methods to Delete Font Cache in Windows 11! - Winsides.com Opens in a new
window ](https://winsides.com/5-easy-methods-to-delete-font-cache-in-
windows-11/)

Sources read but not used in the report

[![](https://t0.gstatic.com/faviconV2?url=https://stackoverflow.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)stackoverflow.comHow to programmatically clear the filesystem memory cache in C++ on a Linux system? Opens in a new window ](https://stackoverflow.com/questions/6818606/how-to-programmatically-clear-the-filesystem-memory-cache-in-c-on-a-linux-syst)[![](https://t3.gstatic.com/faviconV2?url=https://learn.microsoft.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)learn.microsoft.comHow to clear memory cached files programmatically with C++? Specifically Notepad cache? Opens in a new window ](https://learn.microsoft.com/en-us/answers/questions/1866351/how-to-clear-memory-cached-files-programmatically)[![](https://t0.gstatic.com/faviconV2?url=https://stackoverflow.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)stackoverflow.comc++ - Flushing the cache to prevent benchmarking fluctiations - Stack Overflow Opens in a new window ](https://stackoverflow.com/questions/34460744/flushing-the-cache-to-prevent-benchmarking-fluctiations)[![](https://t3.gstatic.com/faviconV2?url=https://learn.microsoft.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)learn.microsoft.comWindows with C++ - Exploring Fonts with DirectWrite and Modern C++ - Microsoft Learn Opens in a new window ](https://learn.microsoft.com/en-us/archive/msdn-magazine/2013/november/windows-with-c-exploring-fonts-with-directwrite-and-modern-c)[![](https://t0.gstatic.com/faviconV2?url=https://stackoverflow.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)stackoverflow.comGet a font filepath from name and style in C++/Windows - Stack Overflow Opens in a new window ](https://stackoverflow.com/questions/11387564/get-a-font-filepath-from-name-and-style-in-c-windows)[![](https://t2.gstatic.com/faviconV2?url=https://www.exploit-db.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)exploit-db.comMicrosoft Windows Font Cache Service - Insecure Sections Privilege Escalation - Exploit-DB Opens in a new window ](https://www.exploit-db.com/exploits/47029)[![](https://t3.gstatic.com/faviconV2?url=https://learn.microsoft.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)learn.microsoft.comHow do you delete system-protected fonts? - Microsoft Q&A Opens in a new window ](https://learn.microsoft.com/en-us/answers/questions/3721095/how-do-you-delete-system-protected-fonts)[![](https://t0.gstatic.com/faviconV2?url=https://superuser.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)superuser.comwindows 7 - What is the purpose of the Fonts key in the Registry? - Super User Opens in a new window ](https://superuser.com/questions/813039/what-is-the-purpose-of-the-fonts-key-in-the-registry)[![](https://t1.gstatic.com/faviconV2?url=https://helpcenter.trendmicro.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)helpcenter.trendmicro.comSafely Clean Your Windows Registry: Step-By-Step Guide | Trend Micro Help Center Opens in a new window ](https://helpcenter.trendmicro.com/en-us/article/tmka-20814)[![](https://t3.gstatic.com/faviconV2?url=https://learn.microsoft.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)learn.microsoft.comWindows registry information for advanced users - Microsoft Learn Opens in a new window ](https://learn.microsoft.com/en-us/troubleshoot/windows-server/performance/windows-registry-advanced-users)[![](https://t3.gstatic.com/faviconV2?url=https://learn.microsoft.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)learn.microsoft.comFonts are shown in the Windows 10 registry but can't find them in C:\Windows\Fonts Opens in a new window ](https://learn.microsoft.com/en-us/answers/questions/936980/fonts-are-shown-in-the-windows-10-registry-but-can)[![](https://t3.gstatic.com/faviconV2?url=https://learn.microsoft.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)learn.microsoft.comDeleting Fonts from Windows 10 that don't appear in regedit - Microsoft Learn Opens in a new window ](https://learn.microsoft.com/en-us/answers/questions/3185680/deleting-fonts-from-windows-10-that-dont-appear-in)[![](https://t0.gstatic.com/faviconV2?url=https://stackoverflow.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)stackoverflow.comCan't query, run or stop a Windows Service - c++ - Stack Overflow Opens in a new window ](https://stackoverflow.com/questions/39326284/cant-query-run-or-stop-a-windows-service)

Thoughts

Deconstructing the Request

I am starting by breaking down your request into two main features. The first
is to automatically uninstall an old font when a new one with the same family
name is installed. The second is to create a new 'cleanup' command to remove
fonts whose files are missing and to clear all system font caches.

Analyzing the Codebase

My primary focus is on modifying the existing code. I'll be examining the
`font_ops.cpp` file to understand the current installation logic,
`font_parser.cpp` to see how font names are extracted, and `main.cpp` to
determine how to add the new 'cleanup' command.

Investigating System-Level Changes

The font cache cleaning portion of the 'cleanup' command requires new
information. I'll need to investigate how to programmatically interact with
the Windows Font Cache Service, find the cache file locations (like
`FNTCACHE.DAT`), and identify any relevant registry keys.

Formulating the Plan

After analyzing the code and researching the cache-clearing process, I will
synthesize all this information. The final goal is to produce an extensive
`PLAN.md` document detailing the exact implementation steps for both new
features, as well as updating the `TODO.md` and `CHANGELOG.md` files to match.

Researching uploaded files

![](https://drive-thirdparty.googleusercontent.com/32/type/text/plain)

llms.txt

![](https://www.gstatic.com/lamda/images/immersives/google_logo_icon_2380fba942c84387f09cf.svg)

Researching websites

[![](https://t0.gstatic.com/faviconV2?url=https://stackoverflow.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)stackoverflow.comHow to programmatically clear the filesystem memory cache in C++ on a Linux system?](https://stackoverflow.com/questions/6818606/how-to-programmatically-clear-the-filesystem-memory-cache-in-c-on-a-linux-syst)[![](https://t3.gstatic.com/faviconV2?url=https://luzi-type.ch/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)luzi-type.chSometimes Desktop Fonts do not appear in program menus. In almost all such cases, the problem can be resolved by clearing the Font Cache. - Notes â€“ Luzi Type Foundry](https://luzi-type.ch/notes-font-cache)[![](https://t3.gstatic.com/faviconV2?url=https://learn.microsoft.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)learn.microsoft.comHow to clear memory cached files programmatically with C++? Specifically Notepad cache?](https://learn.microsoft.com/en-us/answers/questions/1866351/how-to-clear-memory-cached-files-programmatically)[![](https://t0.gstatic.com/faviconV2?url=https://stackoverflow.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)stackoverflow.comc++ - Flushing the cache to prevent benchmarking fluctiations - Stack Overflow](https://stackoverflow.com/questions/34460744/flushing-the-cache-to-prevent-benchmarking-fluctiations)[![](https://t3.gstatic.com/faviconV2?url=https://batcmd.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)batcmd.comWindows Font Cache Service - batcmd.com](https://batcmd.com/windows/10/services/fontcache/)[![](https://t3.gstatic.com/faviconV2?url=https://learn.microsoft.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)learn.microsoft.comWindows with C++ - Exploring Fonts with DirectWrite and Modern C++ - Microsoft Learn](https://learn.microsoft.com/en-us/archive/msdn-magazine/2013/november/windows-with-c-exploring-fonts-with-directwrite-and-modern-c)[![](https://t0.gstatic.com/faviconV2?url=https://gist.github.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)gist.github.comRebuild font cache in Windows and reboot your computer in order to solve some font rendering issues - GitHub Gist](https://gist.github.com/brainplot/19816ff07a0c31efee005d34271650e3)[![](https://t0.gstatic.com/faviconV2?url=https://stackoverflow.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)stackoverflow.comGet a font filepath from name and style in C++/Windows - Stack Overflow](https://stackoverflow.com/questions/11387564/get-a-font-filepath-from-name-and-style-in-c-windows)[![](https://t2.gstatic.com/faviconV2?url=https://www.exploit-db.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)exploit-db.comMicrosoft Windows Font Cache Service - Insecure Sections Privilege Escalation - Exploit-DB](https://www.exploit-db.com/exploits/47029)[![](https://t0.gstatic.com/faviconV2?url=https://www.wisecleaner.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)wisecleaner.comHow to Clear Font Cache in Windows 11 - WiseCleaner](https://www.wisecleaner.com/how-to/326-how-to-clear-font-cache-in-windows-11.html)[![](https://t0.gstatic.com/faviconV2?url=https://winsides.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)winsides.com5+ Easy Methods to Delete Font Cache in Windows 11! - Winsides.com](https://winsides.com/5-easy-methods-to-delete-font-cache-in-windows-11/)[![](https://t3.gstatic.com/faviconV2?url=https://learn.microsoft.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)learn.microsoft.comHow to clear the Windows font cache? - Microsoft Learn](https://learn.microsoft.com/en-us/answers/questions/3860093/how-to-clear-the-windows-font-cache)[![](https://t1.gstatic.com/faviconV2?url=https://www.isunshare.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)isunshare.comHow to Delete Font Cache in Windows 10 - iSunshare](https://www.isunshare.com/windows-10/how-to-delete-font-cache-in-windows-10.html)[![](https://t3.gstatic.com/faviconV2?url=https://learn.microsoft.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)learn.microsoft.comHow do you delete system-protected fonts? - Microsoft Q&A](https://learn.microsoft.com/en-us/answers/questions/3721095/how-do-you-delete-system-protected-fonts)[![](https://t0.gstatic.com/faviconV2?url=https://superuser.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)superuser.comwindows 7 - What is the purpose of the Fonts key in the Registry? - Super User](https://superuser.com/questions/813039/what-is-the-purpose-of-the-fonts-key-in-the-registry)[![](https://t1.gstatic.com/faviconV2?url=https://helpcenter.trendmicro.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)helpcenter.trendmicro.comSafely Clean Your Windows Registry: Step-By-Step Guide | Trend Micro Help Center](https://helpcenter.trendmicro.com/en-us/article/tmka-20814)[![](https://t3.gstatic.com/faviconV2?url=https://learn.microsoft.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)learn.microsoft.comWindows registry information for advanced users - Microsoft Learn](https://learn.microsoft.com/en-us/troubleshoot/windows-server/performance/windows-registry-advanced-users)[![](https://t3.gstatic.com/faviconV2?url=https://learn.microsoft.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)learn.microsoft.comFonts are shown in the Windows 10 registry but can't find them in C:\Windows\Fonts](https://learn.microsoft.com/en-us/answers/questions/936980/fonts-are-shown-in-the-windows-10-registry-but-can)[![](https://t3.gstatic.com/faviconV2?url=https://learn.microsoft.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)learn.microsoft.comDeleting Fonts from Windows 10 that don't appear in regedit - Microsoft Learn](https://learn.microsoft.com/en-us/answers/questions/3185680/deleting-fonts-from-windows-10-that-dont-appear-in)[![](https://t0.gstatic.com/faviconV2?url=https://stackoverflow.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)stackoverflow.comProgrammatically restart a Windows Service - c++ - Stack Overflow](https://stackoverflow.com/questions/6126443/programmatically-restart-a-windows-service)[![](https://t3.gstatic.com/faviconV2?url=https://learn.microsoft.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)learn.microsoft.comStopping a Service - Win32 apps - Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/services/stopping-a-service)[![](https://t3.gstatic.com/faviconV2?url=https://learn.microsoft.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)learn.microsoft.comStarting a Service - Win32 apps - Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/services/starting-a-service)[![](https://t3.gstatic.com/faviconV2?url=https://www.codeproject.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)codeproject.comInteract with Windows Services in C++ - CodeProject](https://www.codeproject.com/articles/Interact-with-Windows-Services-in-Cplusplus)[![](https://t0.gstatic.com/faviconV2?url=https://stackoverflow.com/&client=BARD&type=FAVICON&size=256&fallback_opts=TYPE,SIZE,URL)stackoverflow.comCan't query, run or stop a Windows Service - c++ - Stack Overflow](https://stackoverflow.com/questions/39326284/cant-query-run-or-stop-a-windows-service)

Researching uploaded files

![](https://drive-thirdparty.googleusercontent.com/32/type/text/plain)

llms.txt

Pivoting the Plan

My initial analysis of the provided project files reveals they are high-level
documentation, not the full source code. This is a key insight. It means I
cannot modify existing code directly. Instead, I will architect the
implementation plan *as if* I were writing the functions from scratch,
ensuring my plan fits perfectly into the documented file structure and
respects the intended purpose of each file.

Successful Cache Investigation

My research into the 'cleanup' command's cache-clearing feature was highly
effective. I've confirmed the programmatic method for implementation: I must
first stop the 'FontCache' service, then delete specific files from
`C:\Windows\System32` and
`C:\Windows\ServiceProfiles\LocalService\AppData\Local`, and finally restart
the service. This avoids risky registry edits and provides a clear path
forward.

Mapping the 'Install' Feature

For the automatic uninstall feature, I've mapped out the logic. The
`InstallFont` function will first use the `font_parser` logic to get the new
font's family name. It will then check the registry for a font with the same
name. If a conflict is found, it will call the existing `UninstallFontByName`
function on the *old* font before proceeding to install the new one.

Designing the 'Cleanup' Command

I'm designing the 'cleanup' command in two parts. First, it will iterate
through the Windows font registry and check if the associated font file still
exists, removing any orphaned entries. Second, it will perform the
programmatic cache-clearing steps I've already researched. This entire process
will be encapsulated in a new `CleanupFonts` function, called from `main.cpp`
after an administrator-rights check.

Crafting the Documentation

I was unable to view the *content* of your existing documentation files, but
the project rules clearly state their *purpose*. Therefore, I will create the
`PLAN.md`, `TODO.md`, and `CHANGELOG.md` entries from scratch, adhering to the
formats you've defined: a detailed plan, a simplified checklist, and a new
version entry.

Finalizing the Implementation Plan

I now have all the necessary components: the architectural plan for the
codebase, the specific system-level commands for cache cleaning, and the
documentation strategy. I do not need any further research and will now move
to synthesize these findings into the final, comprehensive `PLAN.md` document.
</document_content>
</document>

<document index="24">
<source>issues/999.md</source>
<document_content>
Now /report then /cleanup then /work on next tasks from @TODO.md and from @PLAN.md
</document_content>
</document>

<document index="25">
<source>publish.cmd</source>
<document_content>
@echo off
setlocal enabledelayedexpansion
REM this_file: publish.cmd
REM Package fontlift-win for distribution
REM Usage: publish.cmd [version]
REM   version: Optional semantic version string.

REM ULTIMATE FALLBACK - This version is used if ALL other resolution methods fail
REM This ensures the package NEVER fails due to version resolution issues
set "ULTIMATE_FALLBACK_VERSION=0.0.0"
set "ULTIMATE_FALLBACK_SEMVER=0.0.0-unknown"
set "ULTIMATE_FALLBACK_TAG=v0.0.0-unknown"

set "EXIT_CODE=0"
set "SCRIPT_ROOT=%~dp0"
if "!SCRIPT_ROOT!"=="" set "SCRIPT_ROOT=."

pushd "!SCRIPT_ROOT!" >nul 2>&1
if !ERRORLEVEL! NEQ 0 (
    echo ERROR: Failed to change directory to !SCRIPT_ROOT!
    exit /b 1
)

set "REQUESTED_VERSION=%~1"

REM Multi-level fallback version resolution strategy
REM Level 1: Use provided argument
REM Level 2: Resolve from git via get-version.cmd
REM Level 3: Use hardcoded fallback
if not "!REQUESTED_VERSION!"=="" (
    REM Level 1: Version provided as argument
    set "PUBLISH_SEMVER=!REQUESTED_VERSION!"
    REM Extract base version (before any - or +)
    for /f "tokens=1 delims=-+" %%V in ("!REQUESTED_VERSION!") do set "PUBLISH_VERSION=%%V"
    set "VERSION_TAG=v!REQUESTED_VERSION!"
    echo Using provided version: !PUBLISH_SEMVER!
) else (
    REM Level 2: Try to resolve from git
    call scripts\get-version.cmd
    if !ERRORLEVEL! EQU 0 (
        set "PUBLISH_VERSION=!VERSION_BASE!"
        set "PUBLISH_SEMVER=!VERSION_SEMVER!"
        set "VERSION_TAG=!VERSION_TAG!"
        echo Resolved version from git: !PUBLISH_SEMVER!
    ) else (
        REM Level 3: Fallback to hardcoded version
        echo WARNING: Version resolution failed, using fallback version
        set "PUBLISH_VERSION=0.0.0"
        set "PUBLISH_SEMVER=0.0.0-fallback"
        set "VERSION_TAG=v0.0.0-fallback"
    )
)

REM ULTIMATE SAFETY CHECK - ensure variables are ALWAYS set
REM This is the absolute last line of defense against version resolution failures
if "!PUBLISH_VERSION!"=="" (
    echo WARNING: PUBLISH_VERSION is empty, using ULTIMATE_FALLBACK
    set "PUBLISH_VERSION=!ULTIMATE_FALLBACK_VERSION!"
)
if "!PUBLISH_SEMVER!"=="" (
    echo WARNING: PUBLISH_SEMVER is empty, using ULTIMATE_FALLBACK
    set "PUBLISH_SEMVER=!ULTIMATE_FALLBACK_SEMVER!"
)
if "!VERSION_TAG!"=="" (
    echo WARNING: VERSION_TAG is empty, using ULTIMATE_FALLBACK
    set "VERSION_TAG=!ULTIMATE_FALLBACK_TAG!"
)

echo Creating distribution package for version !VERSION_TAG!... 

REM Check if build output exists
if not exist build\fontlift-win.exe (
    echo ERROR: build\fontlift-win.exe not found
    echo Please run build.cmd first
    set "EXIT_CODE=1"
    goto :cleanup
)

REM Create dist directory if it doesn't exist (using md 2>nul avoids "if not exist" issues)
md dist 2>nul
if exist dist\*.* del /Q dist\*.*

copy build\fontlift-win.exe dist\ >nul
if !ERRORLEVEL! NEQ 0 (
    echo ERROR: Failed to copy fontlift-win.exe
    set "EXIT_CODE=1"
    goto :cleanup
)

echo fontlift-win-cli !VERSION_TAG! > dist\README.txt
echo. >> dist\README.txt
echo Windows CLI tool for font installation/uninstallation >> dist\README.txt
echo. >> dist\README.txt
echo Usage: >> dist\README.txt
echo   fontlift-win.exe list          List installed fonts >> dist\README.txt
echo   fontlift-win.exe install font.ttf   Install font >> dist\README.txt
echo   fontlift-win.exe uninstall -n Arial  Uninstall font >> dist\README.txt
echo   fontlift-win.exe remove -p font.ttf  Remove font and file >> dist\README.txt
echo. >> dist\README.txt
echo See https://github.com/fontlaborg/fontlift-win-cli for documentation >> dist\README.txt

if exist LICENSE copy LICENSE dist\ >nul

set "ZIPFILE=fontlift-win-!VERSION_TAG!.zip"

echo Compressing to !ZIPFILE!... 
powershell -Command "Compress-Archive -Path dist\* -DestinationPath dist\!ZIPFILE! -Force"

if !ERRORLEVEL! NEQ 0 (
    echo ERROR: Failed to create zip archive
    set "EXIT_CODE=1"
    goto :cleanup
)

echo.
echo ===================================
echo Distribution package created!
echo Output: dist\!ZIPFILE!
echo ===================================
dir dist

:cleanup
popd >nul 2>&1
exit /b !EXIT_CODE!
</document_content>
</document>

<document index="26">
<source>scripts/generate-version-rc.cmd</source>
<document_content>
@echo off
REM this_file: scripts/generate-version-rc.cmd
REM Thin wrapper around PowerShell generator to keep compatibility with batch callers.

set "VERSION_INPUT=%~1"
if "%VERSION_INPUT%"=="" (
    echo Error: Version string is required
    echo Usage: generate-version-rc.cmd VERSION
    exit /b 1
)

powershell -NoProfile -ExecutionPolicy Bypass -File "%~dp0generate-version-rc.ps1" -TargetVersion "%VERSION_INPUT%"
exit /b %ERRORLEVEL%
</document_content>
</document>

<document index="27">
<source>scripts/generate-version-rc.ps1</source>
<document_content>
# this_file: scripts/generate-version-rc.ps1

param(
    [Parameter(Mandatory = $true)]
    [string]$TargetVersion
)

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'

$clean = $TargetVersion.Trim()
if (-not $clean) {
    throw [ArgumentException]::new("Version string cannot be empty.")
}

$pattern = '^(?<major>\d+)\.(?<minor>\d+)\.(?<patch>\d+)(?<suffix>[-+].*)?$'
$match = [regex]::Match($clean, $pattern)
if (-not $match.Success) {
    throw [ArgumentException]::new("Invalid semantic version for version.rc: $TargetVersion")
}

$major = [int]$match.Groups['major'].Value
$minor = [int]$match.Groups['minor'].Value
$patch = [int]$match.Groups['patch'].Value
$baseVersion = "{0}.{1}.{2}" -f $major, $minor, $patch
$displayVersion = if ($match.Groups['suffix'].Value) { $clean } else { $baseVersion }

$scriptDir = Split-Path -Parent $MyInvocation.MyCommand.Path
$templatePath = Join-Path $scriptDir '..\templates\version.rc.template'
$outputPath = Join-Path $scriptDir '..\src\version.rc'

if (-not (Test-Path -Path $templatePath)) {
    throw "Template not found: $templatePath"
}

$content = Get-Content -Path $templatePath -Raw
$content = $content -replace '@VERSION_MAJOR@', $major
$content = $content -replace '@VERSION_MINOR@', $minor
$content = $content -replace '@VERSION_PATCH@', $patch
$content = $content -replace '@VERSION_STRING@', $displayVersion

Set-Content -Path $outputPath -Value $content -Encoding Ascii
Write-Host ("Generated {0} using version {1}" -f $outputPath, $displayVersion)
</document_content>
</document>

<document index="28">
<source>scripts/get-version.cmd</source>
<document_content>
@echo off
REM this_file: scripts/get-version.cmd
REM Resolve semantic version information from git tags or provided input.

set "VERSION_BASE="
set "VERSION_SEMVER="
set "VERSION_TAG="

set "REQUESTED_VERSION=%~1"

if "%REQUESTED_VERSION%"=="" (
    for /f "usebackq tokens=1,2 delims==" %%A in (`powershell -NoProfile -ExecutionPolicy Bypass -File "%~dp0get-version.ps1"`) do call :__assign %%A %%B
) else (
    for /f "usebackq tokens=1,2 delims==" %%A in (`powershell -NoProfile -ExecutionPolicy Bypass -File "%~dp0get-version.ps1" -TargetVersion "%REQUESTED_VERSION%"`) do call :__assign %%A %%B
)

if not defined VERSION_BASE (
    >&2 echo Error: Failed to resolve version information.
    exit /b 1
)

echo %VERSION_BASE%
exit /b 0

:__assign
if /I "%~1"=="BASE" set "VERSION_BASE=%~2"
if /I "%~1"=="SEMVER" set "VERSION_SEMVER=%~2"
if /I "%~1"=="TAG" set "VERSION_TAG=%~2"
goto :eof
</document_content>
</document>

<document index="29">
<source>scripts/get-version.ps1</source>
<document_content>
# this_file: scripts/get-version.ps1

param(
    [string]$TargetVersion,
    [ValidateSet('String', 'Json', 'Object')]
    [string]$Format = 'String'
)

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'

function Convert-ToResultObject {
    param(
        [string]$Base,
        [string]$SemVer,
        [string]$Tag
    )

    switch ($Format) {
        'Json' { return [pscustomobject]@{ base = $Base; semver = $SemVer; tag = $Tag } | ConvertTo-Json -Compress }
        'Object' { return [pscustomobject]@{ base = $Base; semver = $SemVer; tag = $Tag } }
        default {
            Write-Output ("BASE={0}" -f $Base)
            Write-Output ("SEMVER={0}" -f $SemVer)
            Write-Output ("TAG={0}" -f $Tag)
        }
    }
}

function Resolve-FromProvidedVersion {
    param([string]$Input)

    $clean = $Input.Trim()
    if (-not $clean) {
        throw [ArgumentException]::new("Version string cannot be empty.")
    }

    $match = [regex]::Match($clean, '^(?<base>\d+\.\d+\.\d+)(?<suffix>[-+].*)?$')
    if (-not $match.Success) {
        throw [ArgumentException]::new("Invalid semantic version: $Input")
    }

    $base = $match.Groups['base'].Value
    $semVer = if ($match.Groups['suffix'].Value) { $clean } else { $base }
    $tag = "v$semVer"

    return [pscustomobject]@{
        Base   = $base
        SemVer = $semVer
        Tag    = $tag
    }
}

function Resolve-FromGit {
    # Attempt to resolve version from git tags
    # Returns $null if git is not available, no tags exist, or describe fails
    $describe = git describe --tags --match 'v[0-9]*.[0-9]*.[0-9]*' --long --dirty 2>$null
    if ($LASTEXITCODE -ne 0 -or -not $describe) {
        return $null
    }

    $pattern = '^v(?<base>\d+\.\d+\.\d+)-(?<distance>\d+)-g(?<sha>[0-9a-f]+)(?<dirty>-dirty)?$'
    $parsed = [regex]::Match($describe.Trim(), $pattern)
    if (-not $parsed.Success) {
        throw "Unable to parse git describe output: $describe"
    }

    $base = $parsed.Groups['base'].Value
    $distance = [int]$parsed.Groups['distance'].Value
    $sha = $parsed.Groups['sha'].Value
    $dirty = $parsed.Groups['dirty'].Success

    if ($distance -eq 0 -and -not $dirty) {
        return [pscustomobject]@{
            Base   = $base
            SemVer = $base
            Tag    = "v$base"
        }
    }

    if (-not $sha) {
        $sha = git rev-parse --short HEAD
    }

    $preParts = @("dev", $distance)
    if ($dirty) {
        $preParts += "dirty"
    }
    $preRelease = ($preParts -join '.')

    $semVer = "$base-$preRelease"
    if ($sha) {
        $semVer = "$semVer+g$sha"
    }

    return [pscustomobject]@{
        Base   = $base
        SemVer = $semVer
        Tag    = "v$semVer"
    }
}

function Resolve-Fallback {
    # Fallback version for repos without tags or when git is unavailable
    # Returns 0.0.0-dev.{count}+g{sha} format
    # Handles missing git gracefully with "unknown" and count 0
    $sha = git rev-parse --short HEAD 2>$null
    if ($LASTEXITCODE -ne 0 -or -not $sha) {
        $sha = "unknown"
    }

    $count = git rev-list --count HEAD 2>$null
    if ($LASTEXITCODE -ne 0 -or -not $count) {
        $count = 0
    }

    $base = "0.0.0"
    $semVer = "{0}-dev.{1}+g{2}" -f $base, $count, $sha

    return [pscustomobject]@{
        Base   = $base
        SemVer = $semVer
        Tag    = "v$semVer"
    }
}

$result =
    if ($TargetVersion -and -not [string]::IsNullOrWhiteSpace($TargetVersion)) {
        try {
            Resolve-FromProvidedVersion -Input $TargetVersion
        } catch {
            Write-Warning "Failed to parse provided version '$TargetVersion': $_"
            Write-Warning "Falling back to git resolution"
            $gitResult = Resolve-FromGit
            if ($gitResult) {
                $gitResult
            } else {
                Resolve-Fallback
            }
        }
    } else {
        $gitResult = Resolve-FromGit
        if ($gitResult) {
            $gitResult
        } else {
            Resolve-Fallback
        }
    }

Convert-ToResultObject -Base $result.Base -SemVer $result.SemVer -Tag $result.Tag
</document_content>
</document>

<document index="30">
<source>src/exit_codes.h</source>
<document_content>
// this_file: src/exit_codes.h
// Exit code constants for fontlift-win-cli
// Copyright 2025 by Fontlab Ltd. Licensed under Apache 2.0
// Defines standard exit codes for CLI operations (success, error, permission denied)

#ifndef EXIT_CODES_H
#define EXIT_CODES_H

// Exit codes used throughout the application
constexpr int EXIT_SUCCESS_CODE = 0;        // Operation successful
constexpr int EXIT_ERROR = 1;                // General error (file not found, operation failed, etc.)
constexpr int EXIT_PERMISSION_DENIED = 2;    // Administrator privileges required

#endif // EXIT_CODES_H
</document_content>
</document>

<document index="31">
<source>src/font_ops.cpp</source>
<document_content>
// this_file: src/font_ops.cpp
// Font operations implementation
// Copyright 2025 by Fontlab Ltd. Licensed under Apache 2.0

#include "exit_codes.h"
#include "font_ops.h"
#include "sys_utils.h"
#include "font_parser.h"
#include <windows.h>
#include <iostream>
#include <vector>
#include <string>
#include <cstring>
#include <set>
#include <algorithm>

// Font registry suffix constants (per Windows font registry naming convention)
constexpr const char* FONT_SUFFIX_TRUETYPE = " (TrueType)";
constexpr const char* FONT_SUFFIX_OPENTYPE = " (OpenType)";

namespace FontOps {
// Font installation, uninstallation, and registry management operations

// Global context for registry enumeration callback
// Windows RegEnumValueA requires a C-style callback function that cannot capture state.
// This global struct holds the configuration and output destination for the ListCallback function,
// enabling stateful enumeration of registry font entries across both system and user registries.
static struct {
    bool showPaths;
    bool showNames;
    std::string fontsDir;
    std::string userFontsDir;
    std::set<std::string>* outputSet;  // Sorted, deduplicated output
} g_listContext;

static struct {
    int removedCount;
    bool changed;
    std::string fontsDir;
    std::string userFontsDir;
} g_cleanupContext;

struct FontMatch {
    std::string file;
    std::string regName;
    bool perUser;
};

// Helper: Resolve relative or absolute font file path
static std::string ResolveFullPath(const char* file, bool perUser) {
    size_t fileLen = strlen(file);
    bool isAbsolute = (fileLen > 0 && (file[0] == '\\' || file[0] == '/')) || (fileLen > 1 && file[1] == ':');
    // Absolute paths are used for per-user fonts, relative paths for system fonts
    if (isAbsolute) return file;
    const std::string& baseDir = perUser ? g_listContext.userFontsDir : g_listContext.fontsDir;
    if (baseDir.empty()) return file;
    return baseDir + "\\" + file;
}

// Helper: Format font output based on display flags (path/name/both)
static std::string FormatOutput(const std::string& path, const char* name) {
    if (g_listContext.showPaths && g_listContext.showNames) return path + "::" + name;
    if (g_listContext.showNames) return name;
    return path;
}

// Windows registry enumeration callback (C-style function pointer required by RegEnumValueA API)
// Called once for each font entry found in the registry (system or user fonts)
// Processes each entry according to g_listContext configuration (paths, names) and stores
// it in a set for sorted, deduplicated output
static void ListCallback(const char* name, const char* file, bool perUser) {
    std::string fullPath = ResolveFullPath(file, perUser);
    std::string output = FormatOutput(fullPath, name);

    g_listContext.outputSet->insert(output);
}

// Helper: Output sorted and deduplicated font list
static void OutputSorted(const std::set<std::string>& outputSet) {
    for (const auto& line : outputSet) {
        std::cout << line << "\n";
    }
}

// Registry cleanup callback: remove entries pointing to missing files
static void CleanupCallback(const char* name, const char* file, bool perUser) {
    if (!file || file[0] == '\0') return;
    size_t len = strlen(file);
    bool isAbsolute = (len > 1 && file[1] == ':') || (len > 0 && (file[0] == '\\' || file[0] == '/'));
    const std::string& baseDir = perUser ? g_cleanupContext.userFontsDir : g_cleanupContext.fontsDir;
    if (!isAbsolute && baseDir.empty()) {
        std::cerr << "    Warning: Skipping registry entry '" << name << "' (unknown base directory).\n";
        return;
    }
    std::string fullPath = isAbsolute ? std::string(file) : baseDir + "\\" + file;
    if (SysUtils::FileExists(fullPath.c_str())) return;

    std::cout << "  - Removing broken entry: " << name << "\n";
    std::cout << "    File not found: " << fullPath << "\n";
    if (SysUtils::RegDeleteFontEntry(name, perUser)) {
        g_cleanupContext.removedCount++;
        g_cleanupContext.changed = true;
    } else {
        std::cerr << "    Warning: Failed to remove registry entry.\n";
    }
}

// Registry cleanup orchestrator: enumerate system and/or user fonts
static int CleanupRegistry(bool includeSystem, bool includeUser) {
    g_cleanupContext.removedCount = 0;
    g_cleanupContext.changed = false;
    g_cleanupContext.fontsDir.clear();
    g_cleanupContext.userFontsDir.clear();

    bool success = true;

    if (includeSystem) {
        g_cleanupContext.fontsDir = SysUtils::GetFontsDirectory();
        if (g_cleanupContext.fontsDir.empty()) {
            std::cerr << "Error: Could not determine system fonts directory.\n";
            success = false;
        } else if (!SysUtils::RegEnumerateFonts(CleanupCallback, false)) {
            std::cerr << "Error: Failed to enumerate system fonts.\n";
            success = false;
        }
    }

    if (includeUser) {
        g_cleanupContext.userFontsDir = SysUtils::GetUserFontsDirectory();
        if (g_cleanupContext.userFontsDir.empty()) {
            std::cerr << "    Warning: Could not determine user fonts directory.\n";
            success = false;
        } else if (!SysUtils::RegEnumerateFonts(CleanupCallback, true)) {
            std::cerr << "    Warning: Failed to enumerate user fonts.\n";
            success = false;
        }
    }

    if (g_cleanupContext.changed) {
        SysUtils::NotifyFontChange();
    }

    return success ? g_cleanupContext.removedCount : -1;
}

int ListFonts(bool showPaths, bool showNames) {
    g_listContext.showPaths = showPaths;
    g_listContext.showNames = showNames;
    g_listContext.fontsDir = SysUtils::GetFontsDirectory();
    g_listContext.userFontsDir = SysUtils::GetUserFontsDirectory();
    if (g_listContext.fontsDir.empty()) {
        std::cerr << "Error: Cannot determine fonts directory\n";
        return EXIT_ERROR;
    }
    std::set<std::string> outputSet;
    g_listContext.outputSet = &outputSet;

    // Enumerate system fonts (HKEY_LOCAL_MACHINE)
    if (!SysUtils::RegEnumerateFonts(ListCallback, false)) {
        std::cerr << "Error: Failed to enumerate system fonts\n";
        return EXIT_ERROR;
    }

    // Enumerate user fonts (HKEY_CURRENT_USER)
    SysUtils::RegEnumerateFonts(ListCallback, true);  // Don't fail if user fonts missing

    OutputSorted(outputSet);
    return EXIT_SUCCESS_CODE;
}

// Helper: Check if file has valid font extension (.ttf, .otf, .ttc, .otc)
static bool HasValidFontExtension(const char* path) noexcept {
    constexpr const char* validExts[] = {".ttf", ".otf", ".ttc", ".otc"};
    std::string pathStr(path);
    // Locale-independent ASCII lowercase conversion
    for (auto& c : pathStr) {
        if (c >= 'A' && c <= 'Z') c = c - 'A' + 'a';
    }
    for (const char* ext : validExts) {
        if (pathStr.length() >= strlen(ext) &&
            pathStr.compare(pathStr.length() - strlen(ext), strlen(ext), ext) == 0) {
            return true;
        }
    }
    return false;
}

static std::vector<std::string> BuildFontRegistryVariants(const char* fontName) {
    return {
        std::string(fontName) + FONT_SUFFIX_TRUETYPE,
        std::string(fontName) + FONT_SUFFIX_OPENTYPE,
        std::string(fontName)
    };
}

// Helper: Validate font file exists and has valid extension before installation
static int ValidateInstallPrerequisites(const char* fontPath) {
    if (!HasValidFontExtension(fontPath)) {
        std::cerr << "Error: Invalid font file extension\n";
        std::cerr << "Solution: Use a valid font file (.ttf, .otf, .ttc, .otc)\n";
        return EXIT_ERROR;
    }
    if (!SysUtils::FileExists(fontPath)) {
        std::cerr << "Error: Font file not found: " << fontPath << "\n";
        std::cerr << "Solution: Check the file path and ensure the font file exists\n";
        return EXIT_ERROR;
    }
    return EXIT_SUCCESS_CODE;
}

// Helper: Extract font name from font file
static int ExtractFontName(const char* fontPath, std::string& outName) {
    if (FontParser::IsCollection(fontPath)) {
        std::vector<std::string> names = FontParser::GetFontsInCollection(fontPath);
        if (names.empty()) {
            std::cerr << "Error: Failed to parse font collection\n";
            return EXIT_ERROR;
        }
        outName = names[0];
        if (names.size() > 1) std::cout << "Note: Collection contains " << names.size() << " fonts\n";
    } else {
        outName = FontParser::GetFontName(fontPath);
        if (outName.empty()) {
            std::cerr << "Error: Failed to parse font name\n";
            return EXIT_ERROR;
        }
    }
    return EXIT_SUCCESS_CODE;
}

// Helper: Search registry for font by name with automatic suffix matching (TrueType/OpenType)
static bool FindFontInRegistry(const char* fontName, std::string& outFile, std::string& outRegName, bool& outPerUser, bool forceSystemOnly = false) {
    const std::vector<std::string> variants = BuildFontRegistryVariants(fontName);

    // If not forcing system-only, first check user registry (HKEY_CURRENT_USER)
    if (!forceSystemOnly) {
        for (const auto& variant : variants) {
            if (SysUtils::RegReadFontEntry(variant.c_str(), outFile, true)) {
                outRegName = variant;
                outPerUser = true;
                return true;
            }
        }
    }

    // Then check system registry (HKEY_LOCAL_MACHINE)
    for (const auto& variant : variants) {
        if (SysUtils::RegReadFontEntry(variant.c_str(), outFile, false)) {
            outRegName = variant;
            outPerUser = false;
            return true;
        }
    }
    return false;
}

static bool FindFontInScope(const char* fontName, bool perUser, FontMatch& match) {
    const std::vector<std::string> variants = BuildFontRegistryVariants(fontName);
    for (const auto& variant : variants) {
        std::string fontFile;
        if (SysUtils::RegReadFontEntry(variant.c_str(), fontFile, perUser)) {
            match.file = fontFile;
            match.regName = variant;
            match.perUser = perUser;
            return true;
        }
    }
    return false;
}

static void CollectFontMatches(const char* fontName, std::vector<FontMatch>& matches) {
    FontMatch userMatch;
    if (FindFontInScope(fontName, true, userMatch)) matches.push_back(userMatch);
    FontMatch systemMatch;
    if (FindFontInScope(fontName, false, systemMatch)) matches.push_back(systemMatch);
}

// Helper: Write font to registry and load into system via AddFontResourceEx
static int RegisterAndLoadFont(const std::string& destPath, const std::string& fontName, bool perUser) {
    std::string regValue = perUser ? destPath : SysUtils::GetFileName(destPath.c_str());
    std::string regName = fontName + FONT_SUFFIX_TRUETYPE;
    std::string existingFile;
    if (SysUtils::RegReadFontEntry(regName.c_str(), existingFile, perUser)) {
        std::cerr << "Warning: Font '" << fontName << "' already installed, overwriting...\n";
    }
    if (!SysUtils::RegWriteFontEntry(regName.c_str(), regValue.c_str(), perUser)) {
        std::cerr << "Error: Failed to register font in registry: " << SysUtils::GetLastErrorMessage() << "\n";
        SysUtils::DeleteFromFontsFolder(SysUtils::GetFileName(destPath.c_str()).c_str());
        return EXIT_ERROR;
    }
    if (AddFontResourceExA(destPath.c_str(), FR_PRIVATE, 0) == 0) {
        std::cerr << "Error: Failed to load font resource: " << SysUtils::GetLastErrorMessage() << "\n";
        SysUtils::RegDeleteFontEntry(regName.c_str(), perUser);
        SysUtils::DeleteFromFontsFolder(SysUtils::GetFileName(destPath.c_str()).c_str());
        return EXIT_ERROR;
    }
    return EXIT_SUCCESS_CODE;
}

// Forward declaration: shared uninstall/remove logic
static int UnloadAndCleanupFont(const std::string& fontFile, const std::string& matchedName, const std::string& fontName, bool deleteFile, bool perUser);

// Helper: Best-effort removal of existing font with matching family name before installation
static void TryUninstallExistingFont(const std::string& fontName, bool forceAdmin) {
    for (unsigned int attempt = 0; attempt < 4; ++attempt) {
        std::string fontFile;
        std::string matchedName;
        bool perUser = false;
        if (!FindFontInRegistry(fontName.c_str(), fontFile, matchedName, perUser, forceAdmin)) return;
        if (!perUser && !SysUtils::IsAdmin()) {
            std::cerr << "Warning: Found older font '" << fontName << "' but cannot remove it without admin privileges.\n";
            return;
        }
        if (!SysUtils::IsValidFontPath(fontFile.c_str())) {
            std::cerr << "Warning: Found invalid registry path for '" << fontName << "', skipping automatic uninstall.\n";
            return;
        }
        if (UnloadAndCleanupFont(fontFile, matchedName, fontName, false, perUser) != EXIT_SUCCESS_CODE) {
            std::cerr << "Warning: Failed to remove existing font '" << fontName << "' before installation.\n";
            return;
        }
        std::cout << "Note: Automatically uninstalled older version of: " << fontName << "\n";
    }
    std::cerr << "Warning: Stopping automatic uninstall for '" << fontName << "' after multiple attempts.\n";
}

static int RemoveFontFromAllScopes(const char* fontName, bool deleteFile, bool forceAdmin) {
    std::vector<FontMatch> matches;
    CollectFontMatches(fontName, matches);

    if (matches.empty()) {
        std::cerr << "Error: Font not found in registry: " << fontName << "\n";
        return EXIT_ERROR;
    }

    const bool isAdmin = SysUtils::IsAdmin();
    bool permissionBlocked = false;
    bool removedAny = false;
    bool sawSystemMatch = false;
    bool hadFailure = false;
    int lastError = EXIT_SUCCESS_CODE;

    for (const auto& match : matches) {
        if (!match.perUser) sawSystemMatch = true;
        if (!match.perUser && !isAdmin) {
            permissionBlocked = true;
            continue;
        }
        if (!SysUtils::IsValidFontPath(match.file.c_str())) {
            std::cerr << "Error: Invalid font path in registry: " << match.file << "\n";
            return EXIT_ERROR;
        }
        int result = UnloadAndCleanupFont(match.file, match.regName, fontName, deleteFile, match.perUser);
        if (result == EXIT_SUCCESS_CODE) {
            removedAny = true;
        } else {
            hadFailure = true;
            lastError = result;
        }
    }

    if (permissionBlocked) {
        std::cerr << "Error: Administrator privileges required for system fonts\n";
        std::cerr << "Solution: Right-click Command Prompt and select 'Run as administrator'.\n";
        if (removedAny) {
            std::cerr << "Note: User-level copy was removed; system copy remains.\n";
        } else if (!forceAdmin && sawSystemMatch) {
            std::cerr << "Tip: Rerun with --admin after elevating to remove system fonts.\n";
        }
        return EXIT_PERMISSION_DENIED;
    }

    if (hadFailure) return lastError;
    if (removedAny) return EXIT_SUCCESS_CODE;

    std::cerr << "Error: Failed to uninstall font: " << fontName << "\n";
    return EXIT_ERROR;
}

// Helper: Remove font from system memory and registry, optionally delete file
static int UnloadAndCleanupFont(const std::string& fontFile, const std::string& matchedName, const std::string& fontName, bool deleteFile, bool perUser) {
    // For per-user fonts, fontFile is already an absolute path
    // For system fonts, fontFile is relative and needs to be combined with system fonts dir
    std::string fullPath;
    bool isAbsolute = (fontFile.length() > 1 && fontFile[1] == ':');
    if (isAbsolute) {
        fullPath = fontFile;
    } else {
        std::string fontsDir = SysUtils::GetFontsDirectory();
        fullPath = fontsDir + "\\" + fontFile;
    }

    // RemoveFontResourceExA failure is non-fatal: font may not be loaded in current process
    // Warning message informs user, but we proceed with registry/file cleanup
    if (RemoveFontResourceExA(fullPath.c_str(), FR_PRIVATE, 0) == 0) {
        std::cerr << "Warning: Failed to unload font resource\n";
    }
    if (!SysUtils::RegDeleteFontEntry(matchedName.c_str(), perUser)) {
        std::cerr << "Error: Failed to remove font from registry\n";
        return EXIT_ERROR;
    }
    if (deleteFile) {
        if (isAbsolute) {
            if (DeleteFileA(fullPath.c_str()) == 0) {
                std::cerr << "Error: Failed to delete font file: " << fullPath << "\n";
                std::cerr << "Font has been uninstalled but file remains\n";
                SysUtils::NotifyFontChange();
                return EXIT_ERROR;
            }
        } else {
            if (!SysUtils::DeleteFromFontsFolder(fontFile.c_str())) {
                std::cerr << "Error: Failed to delete font file: " << fullPath << "\n";
                std::cerr << "Font has been uninstalled but file remains\n";
                SysUtils::NotifyFontChange();
                return EXIT_ERROR;
            }
        }
    }
    SysUtils::NotifyFontChange();
    std::cout << "Successfully " << (deleteFile ? "removed" : "uninstalled") << ": " << fontName << "\n";
    if (!deleteFile) std::cout << "Font file remains at: " << fullPath << "\n";
    else std::cout << "File deleted: " << fullPath << "\n";
    return EXIT_SUCCESS_CODE;
}

int InstallFont(const char* fontPath, bool forceAdmin) {
    int result = ValidateInstallPrerequisites(fontPath);
    if (result != EXIT_SUCCESS_CODE) return result;

    // Determine installation type
    bool isAdmin = SysUtils::IsAdmin();
    bool perUser;

    if (forceAdmin) {
        // User explicitly requested system-level installation
        if (!isAdmin) {
            std::cerr << "Error: Administrator privileges required for system-level installation\n";
            std::cerr << "Solution: Right-click Command Prompt and select 'Run as administrator'\n";
            return EXIT_PERMISSION_DENIED;
        }
        perUser = false;
    } else {
        // Auto-detect based on admin privileges (current behavior)
        perUser = !isAdmin;
        if (perUser) {
            std::cout << "Installing font for current user only (no admin privileges)...\n";
        }
    }

    std::string fontName;
    result = ExtractFontName(fontPath, fontName);
    if (result != EXIT_SUCCESS_CODE) return result;
    TryUninstallExistingFont(fontName, forceAdmin);
    std::string destPath;
    if (!SysUtils::CopyToFontsFolder(fontPath, destPath, perUser)) {
        std::cerr << "Error: Failed to copy font file: " << SysUtils::GetLastErrorMessage() << "\n";
        return EXIT_ERROR;
    }
    result = RegisterAndLoadFont(destPath, fontName, perUser);
    if (result != EXIT_SUCCESS_CODE) return result;
    SysUtils::NotifyFontChange();
    std::cout << "Successfully installed: " << fontName << "\n";
    std::cout << "Location: " << destPath << "\n";
    if (perUser) {
        std::cout << "Note: Font installed for current user only\n";
    }
    return EXIT_SUCCESS_CODE;
}

int UninstallFontByPath(const char* fontPath, bool forceAdmin) {
    // Parse font name
    std::string fontName = FontParser::GetFontName(fontPath);
    if (fontName.empty()) {
        std::cerr << "Error: Failed to parse font name\n";
        return EXIT_ERROR;
    }

    return UninstallFontByName(fontName.c_str(), forceAdmin);
}

// Helper: Check if string is empty or contains only whitespace characters
static bool IsEmptyOrWhitespace(const char* str) noexcept {
    if (!str || *str == '\0') return true;
    for (const char* p = str; *p; ++p) {
        if (*p != ' ' && *p != '\t' && *p != '\n' && *p != '\r') return false;
    }
    return true;
}

int UninstallFontByName(const char* fontName, bool forceAdmin) {
    if (IsEmptyOrWhitespace(fontName)) {
        std::cerr << "Error: Font name cannot be empty\n";
        return EXIT_ERROR;
    }
    return RemoveFontFromAllScopes(fontName, false, forceAdmin);
}

int RemoveFontByPath(const char* fontPath, bool forceAdmin) {
    // Parse font name
    std::string fontName = FontParser::GetFontName(fontPath);
    if (fontName.empty()) {
        std::cerr << "Error: Failed to parse font name\n";
        return EXIT_ERROR;
    }

    return RemoveFontByName(fontName.c_str(), forceAdmin);
}

int RemoveFontByName(const char* fontName, bool forceAdmin) {
    if (IsEmptyOrWhitespace(fontName)) {
        std::cerr << "Error: Font name cannot be empty\n";
        return EXIT_ERROR;
    }
    return RemoveFontFromAllScopes(fontName, true, forceAdmin);
}

int Cleanup(bool includeSystem) {
    std::cout << "Scanning font registry for broken entries...\n";
    int brokenEntries = CleanupRegistry(includeSystem, true);
    bool registryOk = brokenEntries >= 0;
    if (registryOk) {
        std::cout << "Found and removed " << brokenEntries << " broken font entries.\n";
    } else {
        std::cerr << "Error: Failed to scan font registry.\n";
    }

    std::cout << "Clearing font caches...\n";
    bool cachesOk = true;
    if (!SysUtils::ClearUserFontCaches()) {
        std::cerr << "Error: Failed to clear one or more user/third-party caches.\n";
        cachesOk = false;
    }

    if (includeSystem) {
        if (!SysUtils::ClearSystemFontCaches()) {
            std::cerr << "Error: Failed to clear one or more system caches.\n";
            cachesOk = false;
        }
    }

    if (!registryOk || !cachesOk) {
        return EXIT_ERROR;
    }

    std::cout << "Font caches cleared successfully.\n";
    return EXIT_SUCCESS_CODE;
}

} // namespace FontOps
</document_content>
</document>

<document index="32">
<source>src/font_ops.h</source>
<document_content>
// this_file: src/font_ops.h
// Font operations for fontlift-win-cli
// Copyright 2025 by Fontlab Ltd. Licensed under Apache 2.0
// Public API for font installation, uninstallation, removal, and registry enumeration

#ifndef FONT_OPS_H
#define FONT_OPS_H

namespace FontOps {
    // List installed fonts
    // showPaths: display file paths
    // showNames: display font names
    // Output is always sorted; path-only mode removes duplicate paths
    int ListFonts(bool showPaths, bool showNames);

    // Install font from file path
    // forceAdmin: if true, force system-level installation (requires admin)
    // Returns: 0=success, 1=error, 2=permission denied
    int InstallFont(const char* fontPath, bool forceAdmin = false);

    // Uninstall font by path (keeps file)
    // forceAdmin: request system-scope removal; user fonts are still removed when found
    int UninstallFontByPath(const char* fontPath, bool forceAdmin = false);

    // Uninstall font by name (keeps file)
    // forceAdmin: request system-scope removal; user fonts are still removed when found
    int UninstallFontByName(const char* fontName, bool forceAdmin = false);

    // Remove font by path (deletes file)
    // forceAdmin: request system-scope removal; user fonts are still removed when found
    int RemoveFontByPath(const char* fontPath, bool forceAdmin = false);

    // Remove font by name (deletes file)
    // forceAdmin: request system-scope removal; user fonts are still removed when found
    int RemoveFontByName(const char* fontName, bool forceAdmin = false);

    // Cleanup font registry and caches. includeSystem toggles system-wide scope (requires admin when true)
    int Cleanup(bool includeSystem);
}

#endif // FONT_OPS_H
</document_content>
</document>

<document index="33">
<source>src/font_parser.cpp</source>
<document_content>
// this_file: src/font_parser.cpp
// Font file parser implementation
// Copyright 2025 by Fontlab Ltd. Licensed under Apache 2.0

#include "font_parser.h"
#include <fstream>
#include <cstring>

namespace FontParser {
// Font file parsing for TTF, OTF, TTC, and OTC formats

// File size validation constants
constexpr size_t MIN_FONT_FILE_SIZE = 100;           // Minimum valid font file size (bytes)
constexpr size_t MAX_FONT_FILE_SIZE = 50 * 1024 * 1024;  // Maximum font file size (50 MB)

// Font parsing constants
constexpr size_t MAX_NAME_TABLE_SIZE = 1024 * 1024;  // Maximum name table size (1 MB)
constexpr uint32_t MAX_FONTS_IN_COLLECTION = 256;    // Maximum fonts to process in TTC/OTC
constexpr uint16_t MAX_FONT_TABLES = 1000;           // Maximum number of tables in font file

// Font structure constants
constexpr uint32_t NAME_RECORD_SIZE = 12;            // Size of name table record (bytes)
constexpr uint32_t NAME_TABLE_HEADER_SIZE = 6;       // Size of name table header (format + count + stringOffset)
constexpr uint32_t FONT_HEADER_SIZE = 12;            // Size of font header (bytes)
constexpr uint32_t TABLE_RECORD_SIZE = 16;           // Size of table directory record (bytes)
constexpr uint32_t OFFSET_SIZE = 4;                  // Size of TTC offset table entry (bytes)

// Font header field offsets (per OpenType spec)
constexpr uint32_t FONT_NUM_TABLES_OFFSET = 4;      // numTables field offset

// TTC header field offsets (per OpenType spec)
constexpr uint32_t TTC_NUM_FONTS_OFFSET = 8;        // numFonts field offset

// Name table header field offsets (per OpenType spec)
constexpr uint32_t NAME_COUNT_OFFSET = 2;           // count field offset
constexpr uint32_t NAME_STRING_OFFSET = 4;          // stringOffset field offset

// Table directory record field offsets (per OpenType spec)
constexpr uint32_t TABLE_TAG_OFFSET = 0;            // tag field offset
constexpr uint32_t TABLE_CHECKSUM_OFFSET = 4;       // checksum field offset
constexpr uint32_t TABLE_OFFSET_OFFSET = 8;         // offset field offset
constexpr uint32_t TABLE_LENGTH_OFFSET = 12;        // length field offset

// Name record field offsets (per OpenType spec)
constexpr uint32_t NAME_PLATFORM_ID_OFFSET = 0;      // platformID field offset
constexpr uint32_t NAME_ENCODING_ID_OFFSET = 2;      // encodingID field offset
constexpr uint32_t NAME_LANGUAGE_ID_OFFSET = 4;      // languageID field offset
constexpr uint32_t NAME_NAME_ID_OFFSET = 6;          // nameID field offset
constexpr uint32_t NAME_LENGTH_OFFSET = 8;           // length field offset
constexpr uint32_t NAME_OFFSET_OFFSET = 10;          // offset field offset

// Font format signatures (per OpenType spec)
constexpr uint32_t TRUETYPE_SIGNATURE = 0x00010000;  // TrueType font signature
constexpr uint32_t OPENTYPE_SIGNATURE = 0x4F54544F;  // OpenType font signature ('OTTO')

// Font table tags (per OpenType spec)
constexpr uint32_t NAME_TABLE_TAG = 0x6E616D65;      // 'name' table tag
constexpr uint32_t TTC_HEADER_TAG = 0x74746366;      // 'ttcf' TrueType Collection tag

// Name table nameID values (per OpenType spec)
constexpr uint16_t NAME_ID_FONT_FAMILY = 1;          // Font Family name

// Helper: Read big-endian uint16
static uint16_t ReadUInt16BE(const uint8_t* const data) noexcept {
    return (data[0] << 8) | data[1];
}

// Helper: Read big-endian uint32
static uint32_t ReadUInt32BE(const uint8_t* const data) noexcept {
    return (data[0] << 24) | (data[1] << 16) | (data[2] << 8) | data[3];
}

// Helper: Convert UTF-16BE to ASCII (basic conversion)
static std::string UTF16BEToString(const uint8_t* const data, const uint16_t length) noexcept {
    std::string result;
    for (uint16_t i = 0; i < length; i += 2) {
        uint16_t ch = ReadUInt16BE(data + i);
        if (ch < 128) result += static_cast<char>(ch);
    }
    return result;
}

// Helper: Parse name table to extract font family name (nameID=1)
static std::string ExtractNameFromTable(const uint8_t* const nameTable, const uint32_t tableSize) {
    if (tableSize < NAME_TABLE_HEADER_SIZE) return "";

    uint16_t format = ReadUInt16BE(nameTable);
    uint16_t count = ReadUInt16BE(nameTable + NAME_COUNT_OFFSET);
    uint16_t stringOffset = ReadUInt16BE(nameTable + NAME_STRING_OFFSET);

    // Validate count is reasonable (prevent excessive iteration with corrupted files)
    constexpr uint16_t MAX_NAME_RECORDS = 1000;
    if (count > MAX_NAME_RECORDS) return "";

    // Validate stringOffset is within table bounds
    if (stringOffset >= tableSize) return "";

    // Search for family name (nameID = 1)
    for (uint16_t i = 0; i < count; i++) {
        uint32_t recordOffset = NAME_TABLE_HEADER_SIZE + i * NAME_RECORD_SIZE;
        if (recordOffset + NAME_RECORD_SIZE > tableSize) break;

        const uint8_t* record = nameTable + recordOffset;
        uint16_t platformID = ReadUInt16BE(record + NAME_PLATFORM_ID_OFFSET);
        uint16_t encodingID = ReadUInt16BE(record + NAME_ENCODING_ID_OFFSET);
        uint16_t languageID = ReadUInt16BE(record + NAME_LANGUAGE_ID_OFFSET);
        uint16_t nameID = ReadUInt16BE(record + NAME_NAME_ID_OFFSET);
        uint16_t length = ReadUInt16BE(record + NAME_LENGTH_OFFSET);
        uint16_t offset = ReadUInt16BE(record + NAME_OFFSET_OFFSET);

        // Looking for Font Family name
        if (nameID != NAME_ID_FONT_FAMILY) continue;

        // Prefer Windows platform (3) with Unicode encoding (1)
        if (platformID == 3 && encodingID == 1) {
            // Check for overflow in offset arithmetic
            if (offset > tableSize || stringOffset > tableSize - offset) continue;
            uint32_t strOffset = stringOffset + offset;
            // Check for overflow in length arithmetic
            if (length > tableSize - strOffset) continue;
            if (strOffset + length <= tableSize) {
                return UTF16BEToString(nameTable + strOffset, length);
            }
        }
        // Fallback to Mac platform (1)
        else if (platformID == 1) {
            // Check for overflow in offset arithmetic
            if (offset > tableSize || stringOffset > tableSize - offset) continue;
            uint32_t strOffset = stringOffset + offset;
            // Check for overflow in length arithmetic
            if (length > tableSize - strOffset) continue;
            if (strOffset + length <= tableSize) {
                return std::string(reinterpret_cast<const char*>(nameTable + strOffset), length);
            }
        }
    }
    return "";
}

// Helper: Read font tables starting at file offset and extract name
static std::string ParseFontAtOffset(std::ifstream& file, uint32_t offset) {
    // Get file size to validate offset
    file.seekg(0, std::ios::end);
    std::streampos fileSize = file.tellg();
    if (offset >= static_cast<uint32_t>(fileSize)) return "";  // Offset beyond file size

    file.seekg(offset);

    uint8_t header[FONT_HEADER_SIZE];
    if (!file.read(reinterpret_cast<char*>(header), FONT_HEADER_SIZE)) return "";

    // Validate font signature (TrueType or OpenType)
    uint32_t signature = ReadUInt32BE(header);
    if (signature != TRUETYPE_SIGNATURE && signature != OPENTYPE_SIGNATURE) return "";

    uint16_t numTables = ReadUInt16BE(header + FONT_NUM_TABLES_OFFSET);

    // Validate numTables is reasonable (prevent excessive iteration with corrupted files)
    if (numTables > MAX_FONT_TABLES) return "";

    // Find 'name' table
    for (uint16_t i = 0; i < numTables; i++) {
        uint8_t tableRecord[TABLE_RECORD_SIZE];
        if (!file.read(reinterpret_cast<char*>(tableRecord), TABLE_RECORD_SIZE)) return "";

        uint32_t tag = ReadUInt32BE(tableRecord + TABLE_TAG_OFFSET);
        uint32_t tableOffset = ReadUInt32BE(tableRecord + TABLE_OFFSET_OFFSET);
        uint32_t tableLength = ReadUInt32BE(tableRecord + TABLE_LENGTH_OFFSET);

        // Check if this is the 'name' table
        if (tag == NAME_TABLE_TAG) {
            // Sanity check: name table shouldn't exceed maximum size
            if (tableLength == 0 || tableLength > MAX_NAME_TABLE_SIZE) return "";

            std::vector<uint8_t> nameTable(tableLength);
            file.seekg(tableOffset);
            if (!file.read(reinterpret_cast<char*>(nameTable.data()), tableLength)) return "";

            std::string name = ExtractNameFromTable(nameTable.data(), tableLength);
            if (!name.empty()) return name;
        }
    }
    return "";
}

bool IsCollection(const char* fontPath) {
    std::ifstream file(fontPath, std::ios::binary);
    if (!file) return false;

    uint8_t header[4];
    if (!file.read(reinterpret_cast<char*>(header), 4)) return false;

    uint32_t tag = ReadUInt32BE(header);
    return tag == TTC_HEADER_TAG; // Check for 'ttcf' TrueType Collection
}

// Helper: Extract filename without path or extension for fallback font naming
static std::string ExtractFilenameWithoutExtension(const char* fontPath) {
    std::string path(fontPath);
    size_t lastSlash = path.find_last_of("\\/");
    size_t lastDot = path.find_last_of('.');

    if (lastSlash == std::string::npos) lastSlash = 0;
    else lastSlash++;

    if (lastDot > lastSlash) {
        return path.substr(lastSlash, lastDot - lastSlash);
    } else {
        return path.substr(lastSlash);
    }
}

std::string GetFontName(const char* fontPath) {
    std::ifstream file(fontPath, std::ios::binary);
    if (!file) return "";

    // Validate file size: must be within valid range
    file.seekg(0, std::ios::end);
    std::streampos fileSize = file.tellg();
    file.seekg(0, std::ios::beg);

    if (fileSize < MIN_FONT_FILE_SIZE || fileSize > MAX_FONT_FILE_SIZE) {
        return "";  // File too small or too large to be valid font
    }

    std::string name = ParseFontAtOffset(file, 0);
    if (name.empty()) {
        name = ExtractFilenameWithoutExtension(fontPath);
    }

    return name;
}

std::vector<std::string> GetFontsInCollection(const char* fontPath) {
    std::vector<std::string> names;
    std::ifstream file(fontPath, std::ios::binary);
    if (!file) return names;

    // Validate file size: must be within valid range
    file.seekg(0, std::ios::end);
    std::streampos fileSize = file.tellg();
    file.seekg(0, std::ios::beg);

    if (fileSize < MIN_FONT_FILE_SIZE || fileSize > MAX_FONT_FILE_SIZE) {
        return names;  // File too small or too large to be valid font
    }

    uint8_t header[FONT_HEADER_SIZE];
    if (!file.read(reinterpret_cast<char*>(header), FONT_HEADER_SIZE)) return names;

    uint32_t tag = ReadUInt32BE(header);
    if (tag != TTC_HEADER_TAG) return names; // Not a TrueType Collection

    uint32_t numFonts = ReadUInt32BE(header + TTC_NUM_FONTS_OFFSET);

    // Validate numFonts is reasonable (0 or suspiciously large values indicate corruption)
    if (numFonts == 0 || numFonts > MAX_FONTS_IN_COLLECTION) return names;

    // Reserve capacity to avoid reallocations during iteration
    names.reserve(numFonts);

    for (uint32_t i = 0; i < numFonts; i++) {
        uint8_t offsetData[OFFSET_SIZE];
        if (!file.read(reinterpret_cast<char*>(offsetData), OFFSET_SIZE)) break;

        uint32_t fontOffset = ReadUInt32BE(offsetData);
        // Validate offset is within file bounds
        if (fontOffset >= static_cast<uint32_t>(fileSize)) continue;

        std::string name = ParseFontAtOffset(file, fontOffset);

        if (!name.empty()) {
            names.push_back(name);
        }

        // Return to offset table for next font
        // Check for overflow: i + 1 must not exceed UINT32_MAX / OFFSET_SIZE
        if (i + 1 > UINT32_MAX / OFFSET_SIZE) break;
        file.seekg(FONT_HEADER_SIZE + (i + 1) * OFFSET_SIZE);
        if (!file.good()) break;  // Seek failed, stop processing
    }

    return names;
}

} // namespace FontParser
</document_content>
</document>

<document index="34">
<source>src/font_parser.h</source>
<document_content>
// this_file: src/font_parser.h
// Font file parser for fontlift-win-cli
// Copyright 2025 by Fontlab Ltd. Licensed under Apache 2.0
// Parses TTF, OTF, TTC, and OTC font files to extract font family names

#ifndef FONT_PARSER_H
#define FONT_PARSER_H

#include <string>
#include <vector>

namespace FontParser {
    // Extract font family name from TTF/OTF file
    // Returns empty string if parsing fails
    [[nodiscard]] std::string GetFontName(const char* fontPath);

    // Extract all font names from TTC/OTC collection
    // Returns empty vector if parsing fails
    [[nodiscard]] std::vector<std::string> GetFontsInCollection(const char* fontPath);

    // Check if file is a font collection (TTC/OTC)
    [[nodiscard]] bool IsCollection(const char* fontPath);
}

#endif // FONT_PARSER_H
</document_content>
</document>

# File: /Users/adam/Developer/vcs/github.fontlaborg/fontlift-win-cli/src/main.cpp
# Language: cpp

#include #include "exit_codes.h"
#include #include "font_ops.h"
#include #include "sys_utils.h"
#include #include <windows.h>
#include #include <cstring>
#include #include <iostream>
#include #include <vector>


<document index="35">
<source>src/sys_utils.cpp</source>
<document_content>
// this_file: src/sys_utils.cpp
// System utilities implementation
// Copyright 2025 by Fontlab Ltd. Licensed under Apache 2.0

#include "sys_utils.h"
#include <windows.h>
#include <winsvc.h>
#include <shlwapi.h>
#include <filesystem>
#include <system_error>
#include <iostream>
#include <string>

namespace fs = std::filesystem;

namespace {
constexpr DWORD FONT_CACHE_TIMEOUT_MS = 30000;
constexpr DWORD SERVICE_POLL_INTERVAL_MS = 500;
constexpr const wchar_t* FONT_CACHE_SERVICE_NAME = L"FontCache";
constexpr const char* SYSTEM_CACHE_FILE = "C:\\Windows\\System32\\FNTCACHE.DAT";
constexpr const char* SERVICE_CACHE_DIR = "C:\\Windows\\ServiceProfiles\\LocalService\\AppData\\Local\\FontCache";
constexpr const char* ADOBE_CACHE_PREFIX = "AdobeFnt";
constexpr const char* ADOBE_CACHE_EXTENSION = ".lst";

struct ScopedServiceHandles {
    SC_HANDLE manager{nullptr};
    SC_HANDLE service{nullptr};
    ~ScopedServiceHandles() {
        if (service) CloseServiceHandle(service);
        if (manager) CloseServiceHandle(manager);
    }
};
} // namespace

namespace {
std::string GetEnvVariable(const char* name) {
    DWORD required = GetEnvironmentVariableA(name, nullptr, 0);
    if (required == 0) return "";
    std::string value(required, '\0');
    DWORD written = GetEnvironmentVariableA(name, value.data(), required);
    if (written == 0 || written >= required) return "";
    value.resize(written);
    return value;
}

bool OpenFontCacheService(DWORD desiredAccess, ScopedServiceHandles& handles) {
    handles.manager = OpenSCManagerW(nullptr, nullptr, SC_MANAGER_CONNECT);
    if (!handles.manager) {
        std::cerr << "    Warning: Unable to open service manager" << SysUtils::GetLastErrorMessage() << "\n";
        return false;
    }
    handles.service = OpenServiceW(handles.manager, FONT_CACHE_SERVICE_NAME, desiredAccess | SERVICE_QUERY_STATUS);
    if (!handles.service) {
        std::cerr << "    Warning: Unable to open FontCache service" << SysUtils::GetLastErrorMessage() << "\n";
        return false;
    }
    return true;
}

bool WaitForServiceState(SC_HANDLE service, DWORD desiredState, DWORD timeoutMs) {
    DWORD waited = 0;
    SERVICE_STATUS_PROCESS status{};
    DWORD bytesNeeded = 0;
    while (waited <= timeoutMs) {
        if (!QueryServiceStatusEx(service, SC_STATUS_PROCESS_INFO,
                reinterpret_cast<LPBYTE>(&status), sizeof(status), &bytesNeeded)) {
            std::cerr << "    Warning: QueryServiceStatusEx failed" << SysUtils::GetLastErrorMessage() << "\n";
            return false;
        }
        if (status.dwCurrentState == desiredState) return true;
        Sleep(SERVICE_POLL_INTERVAL_MS);
        waited += SERVICE_POLL_INTERVAL_MS;
    }
    std::cerr << "    Warning: Service did not reach desired state within timeout.\n";
    return false;
}

bool StopFontCacheService() {
    ScopedServiceHandles handles;
    if (!OpenFontCacheService(SERVICE_STOP, handles)) return false;
    SERVICE_STATUS_PROCESS status{};
    DWORD bytesNeeded = 0;
    if (!QueryServiceStatusEx(handles.service, SC_STATUS_PROCESS_INFO,
            reinterpret_cast<LPBYTE>(&status), sizeof(status), &bytesNeeded)) {
        std::cerr << "    Warning: QueryServiceStatusEx failed" << SysUtils::GetLastErrorMessage() << "\n";
        return false;
    }
    if (status.dwCurrentState == SERVICE_STOPPED) return true;
    if (!ControlService(handles.service, SERVICE_CONTROL_STOP, reinterpret_cast<LPSERVICE_STATUS>(&status))) {
        DWORD error = GetLastError();
        if (error != ERROR_SERVICE_NOT_ACTIVE) {
            std::cerr << "    Warning: Failed to stop FontCache service" << SysUtils::GetLastErrorMessage() << "\n";
            return false;
        }
    }
    return WaitForServiceState(handles.service, SERVICE_STOPPED, FONT_CACHE_TIMEOUT_MS);
}

bool StartFontCacheService() {
    ScopedServiceHandles handles;
    if (!OpenFontCacheService(SERVICE_START, handles)) return false;
    SERVICE_STATUS_PROCESS status{};
    DWORD bytesNeeded = 0;
    if (!QueryServiceStatusEx(handles.service, SC_STATUS_PROCESS_INFO,
            reinterpret_cast<LPBYTE>(&status), sizeof(status), &bytesNeeded)) {
        std::cerr << "    Warning: QueryServiceStatusEx failed" << SysUtils::GetLastErrorMessage() << "\n";
        return false;
    }
    if (status.dwCurrentState == SERVICE_RUNNING) return true;
    if (!StartServiceW(handles.service, 0, nullptr)) {
        DWORD error = GetLastError();
        if (error != ERROR_SERVICE_ALREADY_RUNNING) {
            std::cerr << "    Warning: Failed to start FontCache service" << SysUtils::GetLastErrorMessage() << "\n";
            return false;
        }
    }
    return WaitForServiceState(handles.service, SERVICE_RUNNING, FONT_CACHE_TIMEOUT_MS);
}

bool DeleteSystemCacheFiles() {
    bool success = true;
    if (DeleteFileA(SYSTEM_CACHE_FILE) == 0) {
        DWORD error = GetLastError();
        if (error != ERROR_FILE_NOT_FOUND) {
            std::cerr << "    Warning: Failed to delete " << SYSTEM_CACHE_FILE << SysUtils::GetLastErrorMessage() << "\n";
            success = false;
        }
    }
    std::error_code ec;
    fs::remove_all(fs::path(SERVICE_CACHE_DIR), ec);
    if (ec) {
        std::cerr << "    Warning: Failed to clean cache directory: " << SERVICE_CACHE_DIR << " (" << ec.message() << ")\n";
        success = false;
    }
    return success;
}

bool DeleteDirectoryTree(const fs::path& path, const char* description) {
    std::error_code ec;
    if (!fs::exists(path, ec)) {
        if (ec) {
            std::cerr << "    Warning: Unable to access " << description << ": " << path.string() << " (" << ec.message() << ")\n";
            return false;
        }
        return true;
    }

    fs::remove_all(path, ec);
    if (ec) {
        std::cerr << "    Warning: Failed to delete " << description << ": " << path.string() << " (" << ec.message() << ")\n";
        return false;
    }
    return true;
}

bool ClearAdobeCachesIn(const fs::path& root) {
    if (root.empty()) return true;
    std::error_code ec;
    if (!fs::exists(root, ec)) {
        if (ec) {
            std::cerr << "    Warning: Unable to access Adobe cache directory: " << root.string() << " (" << ec.message() << ")\n";
            return false;
        }
        return true;
    }

    bool success = true;
    const auto options = fs::directory_options::skip_permission_denied;
    fs::recursive_directory_iterator it(root, options, ec);
    if (ec) {
        std::cerr << "    Warning: Failed to enumerate Adobe cache directory: " << root.string() << " (" << ec.message() << ")\n";
        return false;
    }

    while (it != fs::recursive_directory_iterator()) {
        const fs::path current = it->path();
        std::error_code statusEc;
        bool isFile = it->is_regular_file(statusEc);
        if (statusEc) {
            std::cerr << "    Warning: Failed to query entry in Adobe cache directory: " << current.string() << " (" << statusEc.message() << ")\n";
            success = false;
        } else if (isFile) {
            std::string filename = current.filename().string();
            if (filename.rfind(ADOBE_CACHE_PREFIX, 0) == 0 && current.extension() == ADOBE_CACHE_EXTENSION) {
                std::error_code removeEc;
                if (!fs::remove(current, removeEc)) {
                    if (removeEc) {
                        std::cerr << "    Warning: Failed to delete Adobe cache file: " << current.string() << " (" << removeEc.message() << ")\n";
                        success = false;
                    }
                }
            }
        }

        it.increment(ec);
        if (ec) {
            std::cerr << "    Warning: Failed to continue Adobe cache traversal: " << root.string() << " (" << ec.message() << ")\n";
            success = false;
            break;
        }
    }
    return success;
}
} // namespace

// Registry buffer size constant (Windows registry value limit)
constexpr size_t REGISTRY_BUFFER_SIZE = 512;

namespace SysUtils {
// System utilities for Windows API, registry, file operations, and error handling

std::string GetLastErrorMessage() {
    DWORD error = GetLastError();
    if (error == 0) return "";

    char* msgBuf = nullptr;
    DWORD result = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
                                    NULL, error, 0, reinterpret_cast<LPSTR>(&msgBuf), 0, NULL);

    std::string message;
    if (result != 0 && msgBuf) {
        message = msgBuf;
        LocalFree(msgBuf);
    } else {
        // FormatMessageA failed, return error code only
        return " (Error " + std::to_string(error) + ")";
    }

    // Remove trailing newlines
    while (!message.empty() && (message.back() == '\n' || message.back() == '\r')) {
        message.pop_back();
    }

    return " (Error " + std::to_string(error) + ": " + message + ")";
}

bool IsAdmin() {
    BOOL isAdmin = FALSE;
    PSID adminGroup = NULL;
    SID_IDENTIFIER_AUTHORITY ntAuthority = SECURITY_NT_AUTHORITY;

    if (AllocateAndInitializeSid(&ntAuthority, 2,
        SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS,
        0, 0, 0, 0, 0, 0, &adminGroup)) {
        CheckTokenMembership(NULL, adminGroup, &isAdmin);
        FreeSid(adminGroup);
    }
    return isAdmin != FALSE;
}

std::string GetFontsDirectory() {
    char winDir[MAX_PATH];
    UINT result = GetWindowsDirectoryA(winDir, MAX_PATH);
    if (result == 0 || result >= MAX_PATH) {
        return "";  // Failed or path truncated
    }
    std::string fontsDir = winDir;
    fontsDir += "\\Fonts";
    return fontsDir;
}

std::string GetUserFontsDirectory() {
    char localAppData[MAX_PATH];
    DWORD result = GetEnvironmentVariableA("LOCALAPPDATA", localAppData, MAX_PATH);
    if (result == 0 || result >= MAX_PATH) {
        return "";  // Failed or path truncated
    }
    std::string fontsDir = localAppData;
    fontsDir += "\\Microsoft\\Windows\\Fonts";
    return fontsDir;
}

bool CopyToFontsFolder(const char* sourcePath, std::string& destPath, bool perUser) {
    std::string fontsDir = perUser ? GetUserFontsDirectory() : GetFontsDirectory();
    if (fontsDir.empty()) return false;

    // Ensure the user fonts directory exists
    if (perUser) {
        if (!PathFileExistsA(fontsDir.c_str())) {
            if (CreateDirectoryA(fontsDir.c_str(), NULL) == 0) {
                // Failed to create directory (could be permissions issue)
                return false;
            }
        }
    }

    std::string filename = GetFileName(sourcePath);
    destPath = fontsDir + "\\" + filename;

    return CopyFileA(sourcePath, destPath.c_str(), FALSE) != 0;
}

bool DeleteFromFontsFolder(const char* filename) {
    std::string fontsDir = GetFontsDirectory();
    if (fontsDir.empty()) return false;

    std::string fullPath = fontsDir + "\\" + filename;
    return DeleteFileA(fullPath.c_str()) != 0;
}

bool FileExists(const char* path) {
    return PathFileExistsA(path) != FALSE;
}

std::string GetFileName(const char* path) {
    if (!path || path[0] == '\0') return "";
    const char* filename = PathFindFileNameA(path);
    return filename ? std::string(filename) : "";
}

// Helper: Check for path traversal attempts (../ or ..\)
static bool HasPathTraversal(const std::string& const path) noexcept {
    return path.find("..\\") != std::string::npos || path.find("../") != std::string::npos;
}

// Helper: Validate absolute paths are within fonts directory
static bool IsAbsolutePathInFontsDir(const std::string& const pathStr) noexcept {
    if (pathStr.length() <= 1 || pathStr[1] != ':') return true;

    std::string fontsDir = GetFontsDirectory();
    if (fontsDir.empty()) return false;

    std::string lowerPath = pathStr;
    std::string lowerFonts = fontsDir;
    // Locale-independent ASCII lowercase conversion
    for (auto& c : lowerPath) {
        if (c >= 'A' && c <= 'Z') c = c - 'A' + 'a';
    }
    for (auto& c : lowerFonts) {
        if (c >= 'A' && c <= 'Z') c = c - 'A' + 'a';
    }

    return lowerPath.find(lowerFonts) == 0;
}

bool IsValidFontPath(const char* path) {
    if (!path || strlen(path) == 0) return false;
    std::string pathStr(path);
    if (HasPathTraversal(pathStr)) return false;
    return IsAbsolutePathInFontsDir(pathStr);
}

bool RegReadFontEntry(const char* valueName, std::string& fontFile, bool perUser) {
    // Validate value name length (Windows limit: 16,383 characters)
    if (!valueName || strlen(valueName) > 16383) {
        return false;
    }

    HKEY hKey;
    const char* regPath = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts";
    HKEY rootKey = perUser ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE;

    if (RegOpenKeyExA(rootKey, regPath, 0, KEY_READ, &hKey) != ERROR_SUCCESS) {
        return false;
    }

    char buffer[REGISTRY_BUFFER_SIZE];
    DWORD bufferSize = sizeof(buffer);
    DWORD type;

    LONG result = RegQueryValueExA(hKey, valueName, NULL, &type, reinterpret_cast<LPBYTE>(buffer), &bufferSize);
    RegCloseKey(hKey);

    if (result == ERROR_SUCCESS && type == REG_SZ) {
        // Ensure buffer is null-terminated to prevent overflow
        if (bufferSize > 0 && bufferSize < sizeof(buffer)) {
            buffer[bufferSize] = '\0';
        } else {
            buffer[sizeof(buffer) - 1] = '\0';
        }
        fontFile = buffer;
        return true;
    }
    return false;
}

bool RegWriteFontEntry(const char* valueName, const char* fontFile, bool perUser) {
    // Validate value name length (Windows limit: 16,383 characters)
    if (!valueName || strlen(valueName) > 16383) {
        return false;
    }

    HKEY hKey;
    const char* regPath = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts";
    HKEY rootKey = perUser ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE;

    // For per-user installation, create the registry key if it doesn't exist
    DWORD disposition;
    LONG openResult = perUser
        ? RegCreateKeyExA(rootKey, regPath, 0, NULL, 0, KEY_WRITE, NULL, &hKey, &disposition)
        : RegOpenKeyExA(rootKey, regPath, 0, KEY_WRITE, &hKey);

    if (openResult != ERROR_SUCCESS) {
        return false;
    }

    size_t pathLen = strlen(fontFile);
    // Validate length doesn't overflow DWORD (extremely unlikely but defensive)
    if (pathLen >= MAXDWORD) {
        RegCloseKey(hKey);
        return false;
    }

    LONG result = RegSetValueExA(hKey, valueName, 0, REG_SZ,
        reinterpret_cast<const BYTE*>(fontFile), static_cast<DWORD>(pathLen + 1));

    RegCloseKey(hKey);
    return result == ERROR_SUCCESS;
}

bool RegDeleteFontEntry(const char* valueName, bool perUser) {
    // Validate value name length (Windows limit: 16,383 characters)
    if (!valueName || strlen(valueName) > 16383) {
        return false;
    }

    HKEY hKey;
    const char* regPath = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts";
    HKEY rootKey = perUser ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE;

    if (RegOpenKeyExA(rootKey, regPath, 0, KEY_WRITE, &hKey) != ERROR_SUCCESS) {
        return false;
    }

    LONG result = RegDeleteValueA(hKey, valueName);
    RegCloseKey(hKey);
    return result == ERROR_SUCCESS;
}

bool RegEnumerateFonts(void (*callback)(const char* name, const char* file, bool perUser), bool perUser) {
    HKEY hKey;
    const char* regPath = "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts";
    HKEY rootKey = perUser ? HKEY_CURRENT_USER : HKEY_LOCAL_MACHINE;

    if (RegOpenKeyExA(rootKey, regPath, 0, KEY_READ, &hKey) != ERROR_SUCCESS) {
        return false;
    }

    char valueName[REGISTRY_BUFFER_SIZE];
    BYTE valueData[REGISTRY_BUFFER_SIZE];
    DWORD index = 0;

    while (true) {
        DWORD nameSize = sizeof(valueName);
        DWORD dataSize = sizeof(valueData);
        DWORD type;

        LONG result = RegEnumValueA(hKey, index++, valueName, &nameSize,
            NULL, &type, valueData, &dataSize);

        if (result == ERROR_NO_MORE_ITEMS) break;
        if (result != ERROR_SUCCESS) continue;
        if (type != REG_SZ) continue;

        // Ensure null-termination for safety
        if (dataSize > 0 && dataSize < sizeof(valueData)) {
            valueData[dataSize] = '\0';
        } else {
            valueData[sizeof(valueData) - 1] = '\0';
        }

        callback(valueName, reinterpret_cast<const char*>(valueData), perUser);
    }

    RegCloseKey(hKey);
    return true;
}

void NotifyFontChange() {
    // SendMessage return value not checked: broadcast notification is best-effort
    // Applications refresh fonts asynchronously; failure doesn't affect font installation success
    SendMessage(HWND_BROADCAST, WM_FONTCHANGE, 0, 0);
}

bool ClearUserFontCaches() {
    bool success = true;

    std::string localAppData = GetEnvVariable("LOCALAPPDATA");
    if (!localAppData.empty()) {
        fs::path local(localAppData);
        std::cout << "  - Clearing Windows user font cache directories...\n";
        if (!DeleteDirectoryTree(local / "FontCache", "user font cache directory")) success = false;
        if (!DeleteDirectoryTree(local / "Microsoft" / "Windows" / "FontCache", "user Microsoft font cache directory")) success = false;
        std::cout << "  - Removing Adobe cache files (LocalAppData)...\n";
        if (!ClearAdobeCachesIn(local / "Adobe")) success = false;
    } else {
        std::cerr << "    Warning: LOCALAPPDATA environment variable not set; skipping user font cache directories.\n";
    }

    std::string roamingAppData = GetEnvVariable("APPDATA");
    if (!roamingAppData.empty()) {
        std::cout << "  - Removing Adobe cache files (AppData)...\n";
        if (!ClearAdobeCachesIn(fs::path(roamingAppData) / "Adobe")) success = false;
    } else {
        std::cerr << "    Warning: APPDATA environment variable not set; skipping roaming Adobe caches.\n";
    }

    return success;
}

bool ClearSystemFontCaches() {
    std::cout << "  - Stopping Windows Font Cache Service (FontCache)...\n";
    if (!StopFontCacheService()) {
        std::cerr << "    Error: Failed to stop font cache service.\n";
        return false;
    }
    std::cout << "  - Deleting cache files...\n";
    bool deleted = DeleteSystemCacheFiles();
    if (!deleted) std::cerr << "    Warning: Could not delete all cache files.\n";
    std::cout << "  - Starting Windows Font Cache Service (FontCache)...\n";
    if (!StartFontCacheService()) {
        std::cerr << "    Error: Failed to restart font cache service.\n";
        return false;
    }
    return deleted;
}

} // namespace SysUtils
</document_content>
</document>

<document index="36">
<source>src/sys_utils.h</source>
<document_content>
// this_file: src/sys_utils.h
// System utilities for fontlift-win-cli
// Copyright 2025 by Fontlab Ltd. Licensed under Apache 2.0
// Windows API wrappers for file operations, registry management, and system utilities

#ifndef SYS_UTILS_H
#define SYS_UTILS_H

#include <string>

namespace SysUtils {
    // Get Windows error message from GetLastError()
    [[nodiscard]] std::string GetLastErrorMessage();

    // Check if running with administrator privileges
    [[nodiscard]] bool IsAdmin();

    // Get Windows fonts directory path (system)
    [[nodiscard]] std::string GetFontsDirectory();

    // Get user fonts directory path
    [[nodiscard]] std::string GetUserFontsDirectory();

    // Copy file to fonts directory (system or user)
    bool CopyToFontsFolder(const char* sourcePath, std::string& destPath, bool perUser = false);

    // Delete file from fonts directory
    bool DeleteFromFontsFolder(const char* filename);

    // Check if file exists
    [[nodiscard]] bool FileExists(const char* path);

    // Get filename from full path
    [[nodiscard]] std::string GetFileName(const char* path);

    // Validate font file path (no path traversal, must be in fonts dir if absolute)
    bool IsValidFontPath(const char* path);

    // Registry operations (perUser: false = HKEY_LOCAL_MACHINE, true = HKEY_CURRENT_USER)
    bool RegReadFontEntry(const char* valueName, std::string& fontFile, bool perUser = false);
    bool RegWriteFontEntry(const char* valueName, const char* fontFile, bool perUser = false);
    bool RegDeleteFontEntry(const char* valueName, bool perUser = false);
    bool RegEnumerateFonts(void (*callback)(const char* name, const char* file, bool perUser), bool perUser = false);

    // Notify system of font changes
    void NotifyFontChange();

    // Clear Windows font caches scoped to the current user
    bool ClearUserFontCaches();

    // Clear system-wide font caches by stopping the FontCache service and deleting cache files
    bool ClearSystemFontCaches();
}

#endif // SYS_UTILS_H
</document_content>
</document>

<document index="37">
<source>tools/chocolateyinstall.ps1</source>
<document_content>
$ErrorActionPreference = 'Stop'

$packageName = 'fontlift-win'
$toolsDir = "$(Split-Path -parent $MyInvocation.MyCommand.Definition)"
$url64 = 'https://github.com/fontlaborg/fontlift-win-cli/releases/download/v1.1.24/fontlift-win-v1.1.24.zip'

$packageArgs = @{
  packageName   = $packageName
  unzipLocation = $toolsDir
  url64bit      = $url64
  checksum64    = ''
  checksumType64= 'sha256'
}

Install-ChocolateyZipPackage @packageArgs
</document_content>
</document>

<document index="38">
<source>tools/cleanup-harness.ps1</source>
<document_content>
# this_file: tools/cleanup-harness.ps1
# Throwaway harness to seed broken font registry entries and drive cleanup
# made by FontLab https://www.fontlab.com/
param(
    [ValidateSet("User", "System", "Both")]
    [string]$Scope = "User",

    [string]$FontNamePrefix = "FontLiftHarness",

    [int]$EntryCount = 2,

    [string]$BinaryPath = "fontlift-win.exe",

    [switch]$RunCleanup,

    [switch]$VerboseOutput
)

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

function Assert-WindowsHost {
    if ($env:OS -notlike "*Windows*") {
        throw "This harness must run on Windows. Aborting to avoid registry edits on non-Windows hosts."
    }
}

function Assert-AdminIfNeeded {
    param([bool]$RequiresAdmin)
    if (-not $RequiresAdmin) { return }
    $currentIdentity = [Security.Principal.WindowsIdentity]::GetCurrent()
    $principal = New-Object Security.Principal.WindowsPrincipal($currentIdentity)
    if (-not $principal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
        throw "System scope requires an elevated shell. Re-run PowerShell as Administrator."
    }
}

function New-OrphanedEntry {
    param(
        [string]$Name,
        [string]$Value,
        [bool]$PerUser
    )

    $root = $PerUser ? "HKCU:" : "HKLM:"
    $path = Join-Path $root "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts"

    if ($VerboseOutput) {
        Write-Host "  - Seeding $($PerUser ? "user" : "system") entry:`t$Name -> $Value"
    }

    New-Item -Path $path -Force | Out-Null
    New-ItemProperty -Path $path -Name $Name -Value $Value -PropertyType String -Force | Out-Null
}

function Remove-EntryIfPresent {
    param(
        [string]$Name,
        [bool]$PerUser
    )
    $root = $PerUser ? "HKCU:" : "HKLM:"
    $path = Join-Path $root "SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts"
    Remove-ItemProperty -Path $path -Name $Name -ErrorAction SilentlyContinue
}

function Get-MissingPathValue {
    param(
        [bool]$PerUser,
        [int]$Index
    )
    if ($PerUser) {
        $userFonts = Join-Path $env:LOCALAPPDATA "Microsoft\\Windows\\Fonts"
        return Join-Path $userFonts ("missing-" + $Index + ".ttf")
    }
    # System registry stores relative filenames
    return ("MissingHarness-" + $Index + ".ttf")
}

function Invoke-FontliftCleanup {
    param([bool]$IncludeSystem)
    $args = @("cleanup")
    if ($IncludeSystem) { $args += "--admin" }

    Write-Host "Running cleanup command: $BinaryPath $($args -join ' ')" -ForegroundColor Cyan
    & $BinaryPath @args
    if ($LASTEXITCODE -ne 0) {
        Write-Warning "Cleanup exited with code $LASTEXITCODE. Check console output above."
    } else {
        Write-Host "Cleanup completed with exit code 0." -ForegroundColor Green
    }
}

Assert-WindowsHost
$seedUser = $Scope -in @("User", "Both")
$seedSystem = $Scope -in @("System", "Both")
Assert-AdminIfNeeded -RequiresAdmin:$seedSystem

Write-Host "Seeding $EntryCount orphaned font entries (scope: $Scope)..." -ForegroundColor Cyan
for ($i = 1; $i -le $EntryCount; $i++) {
    $name = "$FontNamePrefix-$i (TrueType)"
    if ($seedUser) {
        Remove-EntryIfPresent -Name $name -PerUser:$true
        $userValue = Get-MissingPathValue -PerUser:$true -Index:$i
        New-OrphanedEntry -Name $name -Value $userValue -PerUser:$true
    }
    if ($seedSystem) {
        Remove-EntryIfPresent -Name $name -PerUser:$false
        $systemValue = Get-MissingPathValue -PerUser:$false -Index:$i
        New-OrphanedEntry -Name $name -Value $systemValue -PerUser:$false
    }
}

Write-Host "Done seeding orphaned entries. Run 'RegEdit' to confirm under Fonts key." -ForegroundColor Green

if ($RunCleanup) {
    Invoke-FontliftCleanup -IncludeSystem:$seedSystem
}

Write-Host "Harness complete. Reminder: Only run on disposable test VMs." -ForegroundColor Yellow
</document_content>
</document>

<document index="39">
<source>tools/collect-fontlift-transcripts.ps1</source>
<document_content>
# this_file: tools/collect-fontlift-transcripts.ps1
# Wrapper to record real fontlift console transcripts for docs/support
# made by FontLab https://www.fontlab.com/
param(
    [Parameter(Mandatory = $true)]
    [ValidateSet("cleanup-user", "cleanup-admin", "uninstall-missing", "auto-uninstall")]
    [string]$Scenario,

    [string]$BinaryPath = "fontlift-win.exe",

    [string]$OutputDir = "transcripts",

    [string]$FontPath
)

Set-StrictMode -Version Latest
$ErrorActionPreference = "Stop"

function Assert-WindowsHost {
    if ($env:OS -notlike "*Windows*") {
        throw "This recorder must run on Windows. Aborting to avoid invalid results."
    }
}

function Assert-AdminIfNeeded {
    param([bool]$RequiresAdmin)
    if (-not $RequiresAdmin) { return }
    $identity = [Security.Principal.WindowsIdentity]::GetCurrent()
    $principal = New-Object Security.Principal.WindowsPrincipal($identity)
    if (-not $principal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)) {
        throw "Scenario '$Scenario' expects an elevated PowerShell session (Run as Administrator)."
    }
}

function Run-Command {
    param([string[]]$Args)
    $display = $Args -join " "
    Write-Host "Running: $BinaryPath $display" -ForegroundColor Cyan
    & $BinaryPath @Args | Out-Default
    $exit = $LASTEXITCODE
    Write-Host "ExitCode: $exit" -ForegroundColor Yellow
}

Assert-WindowsHost

if ($Scenario -eq "cleanup-admin") {
    Assert-AdminIfNeeded -RequiresAdmin:$true
}

if ($Scenario -eq "auto-uninstall" -and [string]::IsNullOrWhiteSpace($FontPath)) {
    throw "auto-uninstall scenario requires -FontPath pointing to a valid font file."
}

New-Item -ItemType Directory -Path $OutputDir -Force | Out-Null
$timestamp = Get-Date -Format "yyyyMMdd-HHmmss"
$transcriptPath = Join-Path $OutputDir ("fontlift-" + $Scenario + "-" + $timestamp + ".txt")

Start-Transcript -Path $transcriptPath | Out-Null

switch ($Scenario) {
    "cleanup-user" {
        Run-Command @("cleanup")
    }
    "cleanup-admin" {
        Run-Command @("cleanup", "--admin")
    }
    "uninstall-missing" {
        Run-Command @("uninstall", "-n", "MissingFont")
    }
    "auto-uninstall" {
        Run-Command @("install", $FontPath)
        Run-Command @("install", $FontPath)
    }
    default {
        throw "Unhandled scenario: $Scenario"
    }
}

Stop-Transcript | Out-Null
Write-Host "Transcript saved to $transcriptPath" -ForegroundColor Green
</document_content>
</document>

<document index="40">
<source>tools/test-binary-name.sh</source>
<document_content>
#!/usr/bin/env bash
# this_file: tools/test-binary-name.sh
# Verifies the project is configured to build and package fontlift-win.exe
# Fails fast if any key files still reference the old binary name.

set -euo pipefail

root_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"

assert_contains() {
  local file="$1"
  local pattern="$2"
  if ! grep -Fq "$pattern" "$file"; then
    echo "Expected pattern not found: '$pattern' in $file" >&2
    exit 1
  fi
}

assert_contains "$root_dir/build.cmd" "/OUT:build\\fontlift-win.exe"
assert_contains "$root_dir/publish.cmd" "build\\fontlift-win.exe"
assert_contains "$root_dir/publish.cmd" "fontlift-win-"
assert_contains "$root_dir/templates/version.rc.template" "\"InternalName\", \"fontlift-win\""
assert_contains "$root_dir/templates/version.rc.template" "\"OriginalFilename\", \"fontlift-win.exe\""
assert_contains "$root_dir/src/main.cpp" "fontlift-win - Windows Font Management CLI"
assert_contains "$root_dir/README.md" "fontlift-win list"

echo "Binary name checks passed."
</document_content>
</document>

</documents>